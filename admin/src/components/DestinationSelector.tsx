"use client";

import { useState, useEffect, useCallback, useMemo } from "react";
import Link from "next/link";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Database,
  Webhook,
  Loader2,
  Plus,
  AlertTriangle,
  Download,
  ChevronRight,
} from "lucide-react";
import {
  integrationsApi,
  Integration,
  SupabaseColumnSchema,
} from "@/utils/apiClient";
import { SupabaseTablePicker } from "@/components/SupabaseTablePicker";
import { ContextColumnsSection, ContextColumnConfig } from "@/components/ContextColumnsSection";
import { WebhookDestinationConfig } from "@/components/WebhookDestinationConfig";
import { ColumnMappingEditor } from "@/components/ColumnMappingEditor";
import type { ColumnMappingResult } from "@/components/ColumnMappingEditor";
import { isCloudMode } from "@/lib/features";
import { ImporterField } from "@/components/AddColumnForm";
import { SchemaPreview } from "@/components/SchemaPreview";
import { ImportConfirmationModal } from "@/components/ImportConfirmationModal";

// Columns that are typically auto-generated and shouldn't be imported
const AUTO_GENERATED_COLUMNS = ["id", "created_at", "updated_at", "deleted_at"];

function isAutoGeneratedColumn(columnName: string): boolean {
  return AUTO_GENERATED_COLUMNS.includes(columnName.toLowerCase());
}

function getAutoGeneratedColumns(columns: SupabaseColumnSchema[]): SupabaseColumnSchema[] {
  return columns.filter((col) => isAutoGeneratedColumn(col.column_name));
}

export interface DestinationConfig {
  integrationId: string | null;
  integrationType: "supabase" | "webhook" | null;
  tableName: string | null;
  columnMapping: Record<string, string>;
  contextMapping: Record<string, string>;
  supabaseColumns: SupabaseColumnSchema[];
  contextColumns: ContextColumnConfig[];
  mappedColumns: SupabaseColumnSchema[];
  ignoredColumns: string[];
  // Webhook fields
  webhookUrl?: string;
  signingSecret?: string | null;
}

interface DestinationSelectorProps {
  value: DestinationConfig;
  onChange: (config: DestinationConfig) => void;
  onImportSchema?: (columns: SupabaseColumnSchema[]) => void;
  hasExistingColumns?: boolean;
  importerFields?: ImporterField[];
  schemaSource?: "csv" | "manual" | "database";
  /** Pre-fetched integrations - if provided, skips internal fetch */
  integrations?: Integration[];
}

export function DestinationSelector({
  value,
  onChange,
  onImportSchema,
  hasExistingColumns = false,
  importerFields = [],
  schemaSource,
  integrations: externalIntegrations,
}: DestinationSelectorProps) {
  const [internalIntegrations, setInternalIntegrations] = useState<Integration[]>([]);
  const [isLoading, setIsLoading] = useState(!externalIntegrations);
  const [isLoadingSecret, setIsLoadingSecret] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showImportConfirmation, setShowImportConfirmation] = useState(false);
  const [isImported, setIsImported] = useState(false);
  const cloudMode = isCloudMode();

  // Use external integrations if provided, otherwise use internal state
  const integrations = externalIntegrations ?? internalIntegrations;

  useEffect(() => {
    // Skip fetch if integrations provided externally
    if (externalIntegrations) {
      setIsLoading(false);
      return;
    }
    fetchIntegrations();
  }, [externalIntegrations]);

  const fetchIntegrations = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await integrationsApi.getIntegrations();
      setInternalIntegrations(data);
    } catch (err) {
      console.error("Failed to fetch integrations:", err);
      setError("Failed to load integrations");
    } finally {
      setIsLoading(false);
    }
  };

  const handleIntegrationChange = async (integrationId: string) => {
    if (integrationId === "__none__") {
      onChange({
        integrationId: null,
        integrationType: null,
        tableName: null,
        columnMapping: {},
        contextMapping: {},
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        ignoredColumns: [],
        webhookUrl: undefined,
        signingSecret: undefined,
      });
      return;
    }

    const integration = integrations.find((i) => i.id === integrationId);
    if (integration) {
      const baseConfig: DestinationConfig = {
        integrationId: integration.id,
        integrationType: integration.type,
        tableName: null,
        columnMapping: {},
        contextMapping: {},
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        ignoredColumns: [],
        webhookUrl: undefined,
        signingSecret: undefined,
      };

      // For webhook integrations, fetch the signing secret
      if (integration.type === "webhook" && cloudMode) {
        setIsLoadingSecret(true);
        try {
          const secretData = await integrationsApi.getWebhookSecret(integration.id);
          baseConfig.signingSecret = secretData.webhook_secret;
        } catch (err) {
          console.error("Failed to fetch webhook secret:", err);
          // Continue without the secret - it's optional for display
        } finally {
          setIsLoadingSecret(false);
        }
      }

      onChange(baseConfig);
    }
  };

  const handleWebhookUrlChange = useCallback((url: string) => {
    onChange({
      ...value,
      webhookUrl: url,
    });
  }, [value, onChange]);

  const handleTableSelect = useCallback(async (
    tableName: string | null,
    columns: SupabaseColumnSchema[]
  ) => {
    if (!tableName || !value.integrationId) {
      onChange({
        ...value,
        tableName: null,
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        ignoredColumns: [],
        columnMapping: {},
        contextMapping: {},
      });
      setIsImported(false);
      return;
    }

    // Reset import state when table changes
    setIsImported(false);

    // Fetch categorized columns from the backend
    try {
      const categorized = await integrationsApi.getCategorizedColumns(
        value.integrationId,
        tableName
      );

      // Convert context columns to ContextColumnConfig format
      const contextCols: ContextColumnConfig[] = categorized.context.map((col) => ({
        columnName: col.column_name,
        contextKey: col.column_name,
        dataType: col.data_type,
        isNullable: col.is_nullable,
      }));

      onChange({
        ...value,
        tableName,
        supabaseColumns: columns,
        contextColumns: contextCols,
        mappedColumns: categorized.mapped,
        ignoredColumns: [],
        // Reset mappings when table changes
        columnMapping: {},
        contextMapping: contextCols.reduce((acc, col) => {
          acc[col.columnName] = col.contextKey;
          return acc;
        }, {} as Record<string, string>),
      });
    } catch (err) {
      console.error("Failed to fetch categorized columns:", err);
      // Fall back to using all columns as mapped
      onChange({
        ...value,
        tableName,
        supabaseColumns: columns,
        contextColumns: [],
        mappedColumns: columns.filter((c) => !isAutoGeneratedColumn(c.column_name)),
        ignoredColumns: [],
        columnMapping: {},
        contextMapping: {},
      });
    }
  }, [value, onChange]);

  const handleContextColumnsChange = useCallback((contextColumns: ContextColumnConfig[]) => {
    // Update both contextColumns and contextMapping
    const newContextMapping = contextColumns.reduce((acc, col) => {
      acc[col.columnName] = col.contextKey;
      return acc;
    }, {} as Record<string, string>);

    onChange({
      ...value,
      contextColumns,
      contextMapping: newContextMapping,
    });
  }, [value, onChange]);

  const handleMoveToMapped = useCallback((columnName: string) => {
    // Find the column in contextColumns and move to mappedColumns
    const contextCol = value.contextColumns.find((c) => c.columnName === columnName);
    if (!contextCol) return;

    const originalColumn = value.supabaseColumns.find((c) => c.column_name === columnName);
    if (!originalColumn) return;

    // Remove from context, add to mapped
    const newContextColumns = value.contextColumns.filter((c) => c.columnName !== columnName);
    const newMappedColumns = [...value.mappedColumns, originalColumn];

    // Update context mapping
    const newContextMapping = { ...value.contextMapping };
    delete newContextMapping[columnName];

    onChange({
      ...value,
      contextColumns: newContextColumns,
      mappedColumns: newMappedColumns,
      contextMapping: newContextMapping,
    });
  }, [value, onChange]);

  const handleMappingChange = useCallback((result: ColumnMappingResult) => {
    onChange({
      ...value,
      columnMapping: result.columnMapping,
      ignoredColumns: result.ignoredColumns,
    });
  }, [value, onChange]);

  const handleImportConfirm = () => {
    if (onImportSchema) {
      onImportSchema(value.mappedColumns);
      setIsImported(true);
    }
    setShowImportConfirmation(false);
  };

  const getIntegrationIcon = (type: string) => {
    switch (type) {
      case "supabase":
        return <Database className="w-4 h-4 text-green-600" />;
      case "webhook":
        return <Webhook className="w-4 h-4 text-blue-600" />;
      default:
        return null;
    }
  };

  const selectedIntegration = integrations.find(
    (i) => i.id === value.integrationId
  );

  // Determine if we should show the column mapping UI
  // Show when: schema wasn't derived from the same destination table
  const shouldShowMappingUI = useMemo(() => {
    if (!value.tableName || !importerFields || importerFields.length === 0) {
      return false;
    }
    // If schema came from "Connect Database" with same table, don't show
    if (schemaSource === "database" && value.tableName) {
      // Check if importer fields match table columns (same table)
      const tableColNames = new Set(
        value.supabaseColumns.map((c) => c.column_name.toLowerCase())
      );
      const allFieldsMatch = importerFields.every((f) =>
        tableColNames.has(f.name.toLowerCase())
      );
      if (allFieldsMatch) {
        return false;
      }
    }
    // For CSV/Manual schemas, or different table, show mapping UI
    return true;
  }, [value.tableName, value.supabaseColumns, importerFields, schemaSource]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Data Destination</CardTitle>
        <CardDescription>
          Choose where imported data should be automatically sent
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Integration selector */}
        <div className="space-y-2">
          <Label htmlFor="integration-select">Integration</Label>
          {isLoading ? (
            <div className="flex items-center gap-2 text-gray-500 text-sm py-2">
              <Loader2 className="w-4 h-4 animate-spin" />
              Loading integrations...
            </div>
          ) : (
            <Select
              value={value.integrationId || "__none__"}
              onValueChange={handleIntegrationChange}
            >
              <SelectTrigger id="integration-select">
                <SelectValue placeholder="Select an integration" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="__none__">
                  <span className="text-gray-500">
                    No integration (manual export only)
                  </span>
                </SelectItem>
                {integrations
                  .filter((integration) => integration.id) // Filter out any with empty IDs
                  .map((integration) => (
                    <SelectItem key={integration.id} value={integration.id}>
                      <div className="flex items-center gap-2">
                        {getIntegrationIcon(integration.type)}
                        <span>{integration.name}</span>
                        <Badge
                          variant="secondary"
                          className="ml-1 text-xs capitalize"
                        >
                          {integration.type}
                        </Badge>
                      </div>
                    </SelectItem>
                  ))}
              </SelectContent>
            </Select>
          )}

          {integrations.length === 0 && !isLoading && (
            <p className="text-sm text-gray-500">
              No integrations configured.{" "}
              <Link
                href="/settings/integrations"
                className="text-blue-600 hover:text-blue-800"
              >
                <Plus className="inline w-3 h-3" /> Add one in Settings
              </Link>
            </p>
          )}
        </div>

        {/* Supabase table picker */}
        {selectedIntegration?.type === "supabase" && value.integrationId && (
          <div className="pt-2 border-t space-y-4">
            <SupabaseTablePicker
              integrationId={value.integrationId}
              selectedTable={value.tableName}
              onTableSelect={handleTableSelect}
              hideSchema={true}
            />

            {/* Column mapping UI - shows when schema source differs from destination */}
            {shouldShowMappingUI && value.mappedColumns.length > 0 && (
              <div className="pt-4 border-t">
                <ColumnMappingEditor
                  key={`${value.tableName}-${importerFields.map(f => f.name).join(',')}`}
                  importerFields={importerFields}
                  tableColumns={value.mappedColumns}
                  initialMapping={value.columnMapping}
                  onChange={handleMappingChange}
                />
              </div>
            )}

            {/* Import schema button - only show when NOT showing mapping UI */}
            {!shouldShowMappingUI && value.supabaseColumns.length > 0 && onImportSchema && (
              <div className="space-y-3">
                <SchemaPreview
                  fromCsvColumns={value.mappedColumns}
                  fromAppColumns={value.contextColumns.map((c) => ({
                    column_name: c.columnName,
                    data_type: c.dataType,
                    is_nullable: c.isNullable,
                  }))}
                  autoGeneratedColumns={getAutoGeneratedColumns(value.supabaseColumns)}
                  isImported={isImported}
                />

                <div className="flex justify-end">
                  <Button
                    type="button"
                    size="sm"
                    onClick={() => setShowImportConfirmation(true)}
                  >
                    <Download className="w-4 h-4 mr-2" />
                    {isImported ? "Re-import Schema" : "Import Schema"}
                  </Button>
                </div>

                <ImportConfirmationModal
                  open={showImportConfirmation}
                  onOpenChange={setShowImportConfirmation}
                  tableName={value.tableName || ""}
                  fromCsvColumns={value.mappedColumns}
                  fromAppColumns={value.contextColumns.map((c) => ({
                    column_name: c.columnName,
                    data_type: c.dataType,
                    is_nullable: c.isNullable,
                  }))}
                  hasExistingColumns={hasExistingColumns || false}
                  onConfirm={handleImportConfirm}
                />

                {isImported && (
                  <div className="text-sm text-gray-600 bg-gray-50 p-3 rounded-lg border">
                    Next: Configure column mapping in the <strong>Columns</strong> tab
                  </div>
                )}
              </div>
            )}

            {/* Context columns section - collapsible */}
            {value.tableName && value.supabaseColumns.length > 0 && (
              <Collapsible>
                <div className="pt-4 border-t">
                  <CollapsibleTrigger className="group flex items-center gap-2 text-sm font-medium hover:text-blue-600 w-full">
                    <ChevronRight className="w-4 h-4 transition-transform group-data-[state=open]:rotate-90" />
                    App-Provided Data
                    {value.contextColumns.length > 0 && (
                      <Badge variant="secondary" className="ml-auto">
                        {value.contextColumns.length}
                      </Badge>
                    )}
                  </CollapsibleTrigger>
                  <CollapsibleContent className="pt-4">
                    <ContextColumnsSection
                      columns={value.contextColumns}
                      onChange={handleContextColumnsChange}
                      availableColumns={value.supabaseColumns.filter(
                        (c) => !isAutoGeneratedColumn(c.column_name)
                      )}
                      onMoveToMapped={handleMoveToMapped}
                    />
                  </CollapsibleContent>
                </div>
              </Collapsible>
            )}
          </div>
        )}

        {/* Webhook configuration */}
        {selectedIntegration?.type === "webhook" && value.integrationId && (
          <div className="pt-2 border-t">
            {isLoadingSecret ? (
              <div className="flex items-center gap-2 text-gray-500 text-sm py-2">
                <Loader2 className="w-4 h-4 animate-spin" />
                Loading webhook configuration...
              </div>
            ) : (
              <WebhookDestinationConfig
                webhookUrl={value.webhookUrl || ""}
                signingSecret={value.signingSecret || null}
                isCloudMode={cloudMode}
                onChange={handleWebhookUrlChange}
              />
            )}
          </div>
        )}

        {/* Help text when no integration selected */}
        {!value.integrationId && !isLoading && integrations.length > 0 && (
          <p className="text-sm text-gray-500">
            Select an integration to automatically send imported data to
            Supabase or a webhook endpoint.
          </p>
        )}
      </CardContent>
    </Card>
  );
}
