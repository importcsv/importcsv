"use client";

import { useState, useEffect, useCallback, useMemo } from "react";
import Link from "next/link";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Database,
  Webhook,
  Loader2,
  Plus,
  AlertTriangle,
  Download,
} from "lucide-react";
import {
  integrationsApi,
  Integration,
  SupabaseColumnSchema,
} from "@/utils/apiClient";
import { SupabaseTablePicker } from "@/components/SupabaseTablePicker";
import { ContextColumnsSection, ContextColumnConfig } from "@/components/ContextColumnsSection";
import { WebhookDestinationConfig } from "@/components/WebhookDestinationConfig";
import { ColumnMappingEditor } from "@/components/ColumnMappingEditor";
import type { ColumnMappingResult } from "@/components/ColumnMappingEditor";
import { isCloudMode } from "@/lib/features";
import { ImporterField } from "@/components/AddColumnForm";

// Columns that are typically auto-generated and shouldn't be imported
const AUTO_GENERATED_COLUMNS = ["id", "created_at", "updated_at", "deleted_at"];

function isAutoGeneratedColumn(columnName: string): boolean {
  return AUTO_GENERATED_COLUMNS.includes(columnName.toLowerCase());
}

export interface DestinationConfig {
  integrationId: string | null;
  integrationType: "supabase" | "webhook" | null;
  tableName: string | null;
  columnMapping: Record<string, string>;
  contextMapping: Record<string, string>;
  supabaseColumns: SupabaseColumnSchema[];
  contextColumns: ContextColumnConfig[];
  mappedColumns: SupabaseColumnSchema[];
  ignoredColumns: string[];
  // Webhook fields
  webhookUrl?: string;
  signingSecret?: string | null;
}

interface DestinationSelectorProps {
  value: DestinationConfig;
  onChange: (config: DestinationConfig) => void;
  onImportSchema?: (columns: SupabaseColumnSchema[]) => void;
  hasExistingColumns?: boolean;
  importerFields?: ImporterField[];
  schemaSource?: "csv" | "manual" | "database";
  /** Pre-fetched integrations - if provided, skips internal fetch */
  integrations?: Integration[];
}

export function DestinationSelector({
  value,
  onChange,
  onImportSchema,
  hasExistingColumns = false,
  importerFields = [],
  schemaSource,
  integrations: externalIntegrations,
}: DestinationSelectorProps) {
  const [internalIntegrations, setInternalIntegrations] = useState<Integration[]>([]);
  const [isLoading, setIsLoading] = useState(!externalIntegrations);
  const [isLoadingSecret, setIsLoadingSecret] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const cloudMode = isCloudMode();

  // Use external integrations if provided, otherwise use internal state
  const integrations = externalIntegrations ?? internalIntegrations;

  useEffect(() => {
    // Skip fetch if integrations provided externally
    if (externalIntegrations) {
      setIsLoading(false);
      return;
    }
    fetchIntegrations();
  }, [externalIntegrations]);

  const fetchIntegrations = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await integrationsApi.getIntegrations();
      setInternalIntegrations(data);
    } catch (err) {
      console.error("Failed to fetch integrations:", err);
      setError("Failed to load integrations");
    } finally {
      setIsLoading(false);
    }
  };

  const handleIntegrationChange = async (integrationId: string) => {
    if (integrationId === "__none__") {
      onChange({
        integrationId: null,
        integrationType: null,
        tableName: null,
        columnMapping: {},
        contextMapping: {},
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        ignoredColumns: [],
        webhookUrl: undefined,
        signingSecret: undefined,
      });
      return;
    }

    const integration = integrations.find((i) => i.id === integrationId);
    if (integration) {
      const baseConfig: DestinationConfig = {
        integrationId: integration.id,
        integrationType: integration.type,
        tableName: null,
        columnMapping: {},
        contextMapping: {},
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        ignoredColumns: [],
        webhookUrl: undefined,
        signingSecret: undefined,
      };

      // For webhook integrations, fetch the signing secret
      if (integration.type === "webhook" && cloudMode) {
        setIsLoadingSecret(true);
        try {
          const secretData = await integrationsApi.getWebhookSecret(integration.id);
          baseConfig.signingSecret = secretData.webhook_secret;
        } catch (err) {
          console.error("Failed to fetch webhook secret:", err);
          // Continue without the secret - it's optional for display
        } finally {
          setIsLoadingSecret(false);
        }
      }

      onChange(baseConfig);
    }
  };

  const handleWebhookUrlChange = useCallback((url: string) => {
    onChange({
      ...value,
      webhookUrl: url,
    });
  }, [value, onChange]);

  const handleTableSelect = useCallback(async (
    tableName: string | null,
    columns: SupabaseColumnSchema[]
  ) => {
    if (!tableName || !value.integrationId) {
      onChange({
        ...value,
        tableName: null,
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        ignoredColumns: [],
        columnMapping: {},
        contextMapping: {},
      });
      return;
    }

    // Fetch categorized columns from the backend
    try {
      const categorized = await integrationsApi.getCategorizedColumns(
        value.integrationId,
        tableName
      );

      // Convert context columns to ContextColumnConfig format
      const contextCols: ContextColumnConfig[] = categorized.context.map((col) => ({
        columnName: col.column_name,
        contextKey: col.column_name,
        dataType: col.data_type,
        isNullable: col.is_nullable,
      }));

      onChange({
        ...value,
        tableName,
        supabaseColumns: columns,
        contextColumns: contextCols,
        mappedColumns: categorized.mapped,
        ignoredColumns: [],
        // Reset mappings when table changes
        columnMapping: {},
        contextMapping: contextCols.reduce((acc, col) => {
          acc[col.columnName] = col.contextKey;
          return acc;
        }, {} as Record<string, string>),
      });
    } catch (err) {
      console.error("Failed to fetch categorized columns:", err);
      // Fall back to using all columns as mapped
      onChange({
        ...value,
        tableName,
        supabaseColumns: columns,
        contextColumns: [],
        mappedColumns: columns.filter((c) => !isAutoGeneratedColumn(c.column_name)),
        ignoredColumns: [],
        columnMapping: {},
        contextMapping: {},
      });
    }
  }, [value, onChange]);

  const handleContextColumnsChange = useCallback((contextColumns: ContextColumnConfig[]) => {
    // Update both contextColumns and contextMapping
    const newContextMapping = contextColumns.reduce((acc, col) => {
      acc[col.columnName] = col.contextKey;
      return acc;
    }, {} as Record<string, string>);

    onChange({
      ...value,
      contextColumns,
      contextMapping: newContextMapping,
    });
  }, [value, onChange]);

  const handleMoveToMapped = useCallback((columnName: string) => {
    // Find the column in contextColumns and move to mappedColumns
    const contextCol = value.contextColumns.find((c) => c.columnName === columnName);
    if (!contextCol) return;

    const originalColumn = value.supabaseColumns.find((c) => c.column_name === columnName);
    if (!originalColumn) return;

    // Remove from context, add to mapped
    const newContextColumns = value.contextColumns.filter((c) => c.columnName !== columnName);
    const newMappedColumns = [...value.mappedColumns, originalColumn];

    // Update context mapping
    const newContextMapping = { ...value.contextMapping };
    delete newContextMapping[columnName];

    onChange({
      ...value,
      contextColumns: newContextColumns,
      mappedColumns: newMappedColumns,
      contextMapping: newContextMapping,
    });
  }, [value, onChange]);

  const handleMappingChange = useCallback((result: ColumnMappingResult) => {
    onChange({
      ...value,
      columnMapping: result.columnMapping,
      ignoredColumns: result.ignoredColumns,
    });
  }, [value, onChange]);

  const getIntegrationIcon = (type: string) => {
    switch (type) {
      case "supabase":
        return <Database className="w-4 h-4 text-green-600" />;
      case "webhook":
        return <Webhook className="w-4 h-4 text-blue-600" />;
      default:
        return null;
    }
  };

  const selectedIntegration = integrations.find(
    (i) => i.id === value.integrationId
  );

  // Determine if we should show the column mapping UI
  // Show when: schema wasn't derived from the same destination table
  const shouldShowMappingUI = useMemo(() => {
    if (!value.tableName || !importerFields || importerFields.length === 0) {
      return false;
    }
    // If schema came from "Connect Database" with same table, don't show
    if (schemaSource === "database" && value.tableName) {
      // Check if importer fields match table columns (same table)
      const tableColNames = new Set(
        value.supabaseColumns.map((c) => c.column_name.toLowerCase())
      );
      const allFieldsMatch = importerFields.every((f) =>
        tableColNames.has(f.name.toLowerCase())
      );
      if (allFieldsMatch) {
        return false;
      }
    }
    // For CSV/Manual schemas, or different table, show mapping UI
    return true;
  }, [value.tableName, value.supabaseColumns, importerFields, schemaSource]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Data Destination</CardTitle>
        <CardDescription>
          Choose where imported data should be automatically sent
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Integration selector */}
        <div className="space-y-2">
          <Label htmlFor="integration-select">Integration</Label>
          {isLoading ? (
            <div className="flex items-center gap-2 text-gray-500 text-sm py-2">
              <Loader2 className="w-4 h-4 animate-spin" />
              Loading integrations...
            </div>
          ) : (
            <Select
              value={value.integrationId || "__none__"}
              onValueChange={handleIntegrationChange}
            >
              <SelectTrigger id="integration-select">
                <SelectValue placeholder="Select an integration" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="__none__">
                  <span className="text-gray-500">
                    No integration (manual export only)
                  </span>
                </SelectItem>
                {integrations
                  .filter((integration) => integration.id) // Filter out any with empty IDs
                  .map((integration) => (
                    <SelectItem key={integration.id} value={integration.id}>
                      <div className="flex items-center gap-2">
                        {getIntegrationIcon(integration.type)}
                        <span>{integration.name}</span>
                        <Badge
                          variant="secondary"
                          className="ml-1 text-xs capitalize"
                        >
                          {integration.type}
                        </Badge>
                      </div>
                    </SelectItem>
                  ))}
              </SelectContent>
            </Select>
          )}

          {integrations.length === 0 && !isLoading && (
            <p className="text-sm text-gray-500">
              No integrations configured.{" "}
              <Link
                href="/settings/integrations"
                className="text-blue-600 hover:text-blue-800"
              >
                <Plus className="inline w-3 h-3" /> Add one in Settings
              </Link>
            </p>
          )}
        </div>

        {/* Supabase table picker */}
        {selectedIntegration?.type === "supabase" && value.integrationId && (
          <div className="pt-2 border-t space-y-4">
            <SupabaseTablePicker
              integrationId={value.integrationId}
              selectedTable={value.tableName}
              onTableSelect={handleTableSelect}
            />

            {/* Column mapping UI - shows when schema source differs from destination */}
            {shouldShowMappingUI && value.mappedColumns.length > 0 && (
              <div className="pt-4 border-t">
                <ColumnMappingEditor
                  key={`${value.tableName}-${importerFields.map(f => f.name).join(',')}`}
                  importerFields={importerFields}
                  tableColumns={value.mappedColumns}
                  initialMapping={value.columnMapping}
                  onChange={handleMappingChange}
                />
              </div>
            )}

            {/* Import schema button - only show when NOT showing mapping UI */}
            {!shouldShowMappingUI && value.supabaseColumns.length > 0 && onImportSchema && (
              <div className="flex items-center justify-between p-3 bg-blue-50 rounded-lg border border-blue-100">
                <div className="text-sm">
                  <p className="font-medium text-blue-900">
                    {hasExistingColumns
                      ? "Replace columns from table schema?"
                      : "Import columns from table schema?"}
                  </p>
                  <p className="text-blue-700">
                    {value.mappedColumns.length} importable columns, {value.contextColumns.length} context columns detected
                  </p>
                </div>
                <Button
                  type="button"
                  size="sm"
                  onClick={() => onImportSchema(value.mappedColumns)}
                >
                  <Download className="w-4 h-4 mr-2" />
                  Import Schema
                </Button>
              </div>
            )}

            {/* Context columns section */}
            {value.tableName && value.supabaseColumns.length > 0 && (
              <div className="pt-4 border-t">
                <ContextColumnsSection
                  columns={value.contextColumns}
                  onChange={handleContextColumnsChange}
                  availableColumns={value.supabaseColumns.filter(
                    (c) => !isAutoGeneratedColumn(c.column_name)
                  )}
                  onMoveToMapped={handleMoveToMapped}
                />
              </div>
            )}
          </div>
        )}

        {/* Webhook configuration */}
        {selectedIntegration?.type === "webhook" && value.integrationId && (
          <div className="pt-2 border-t">
            {isLoadingSecret ? (
              <div className="flex items-center gap-2 text-gray-500 text-sm py-2">
                <Loader2 className="w-4 h-4 animate-spin" />
                Loading webhook configuration...
              </div>
            ) : (
              <WebhookDestinationConfig
                webhookUrl={value.webhookUrl || ""}
                signingSecret={value.signingSecret || null}
                isCloudMode={cloudMode}
                onChange={handleWebhookUrlChange}
              />
            )}
          </div>
        )}

        {/* Help text when no integration selected */}
        {!value.integrationId && !isLoading && integrations.length > 0 && (
          <p className="text-sm text-gray-500">
            Select an integration to automatically send imported data to
            Supabase or a webhook endpoint.
          </p>
        )}
      </CardContent>
    </Card>
  );
}
