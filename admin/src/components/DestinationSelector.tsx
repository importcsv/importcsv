"use client";

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Database,
  Webhook,
  Loader2,
  Plus,
  AlertTriangle,
  Download,
} from "lucide-react";
import {
  integrationsApi,
  Integration,
  SupabaseColumnSchema,
} from "@/utils/apiClient";
import { SupabaseTablePicker } from "@/components/SupabaseTablePicker";
import { ContextColumnsSection, ContextColumnConfig } from "@/components/ContextColumnsSection";
import { SchemaPreview } from "@/components/SchemaPreview";
import { ImportConfirmationModal } from "@/components/ImportConfirmationModal";

// Columns that are typically auto-generated and shouldn't be imported
const AUTO_GENERATED_COLUMNS = ["id", "created_at", "updated_at", "deleted_at"];

function isAutoGeneratedColumn(columnName: string): boolean {
  return AUTO_GENERATED_COLUMNS.includes(columnName.toLowerCase());
}

function getAutoGeneratedColumns(columns: SupabaseColumnSchema[]): SupabaseColumnSchema[] {
  return columns.filter((col) => isAutoGeneratedColumn(col.column_name));
}

export interface DestinationConfig {
  integrationId: string | null;
  integrationType: "supabase" | "webhook" | null;
  tableName: string | null;
  columnMapping: Record<string, string>;
  contextMapping: Record<string, string>;
  supabaseColumns: SupabaseColumnSchema[];
  contextColumns: ContextColumnConfig[];
  mappedColumns: SupabaseColumnSchema[];
}

interface DestinationSelectorProps {
  value: DestinationConfig;
  onChange: (config: DestinationConfig) => void;
  onImportSchema?: (columns: SupabaseColumnSchema[]) => void;
  hasExistingColumns?: boolean;
}

export function DestinationSelector({
  value,
  onChange,
  onImportSchema,
  hasExistingColumns = false,
}: DestinationSelectorProps) {
  const [integrations, setIntegrations] = useState<Integration[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showImportConfirmation, setShowImportConfirmation] = useState(false);
  const [isImported, setIsImported] = useState(false);

  useEffect(() => {
    fetchIntegrations();
  }, []);

  const fetchIntegrations = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await integrationsApi.getIntegrations();
      setIntegrations(data);
    } catch (err) {
      console.error("Failed to fetch integrations:", err);
      setError("Failed to load integrations");
    } finally {
      setIsLoading(false);
    }
  };

  const handleIntegrationChange = (integrationId: string) => {
    if (integrationId === "__none__") {
      onChange({
        integrationId: null,
        integrationType: null,
        tableName: null,
        columnMapping: {},
        contextMapping: {},
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
      });
      return;
    }

    const integration = integrations.find((i) => i.id === integrationId);
    if (integration) {
      onChange({
        integrationId: integration.id,
        integrationType: integration.type,
        tableName: null,
        columnMapping: {},
        contextMapping: {},
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
      });
    }
  };

  const handleTableSelect = useCallback(async (
    tableName: string | null,
    columns: SupabaseColumnSchema[]
  ) => {
    if (!tableName || !value.integrationId) {
      onChange({
        ...value,
        tableName: null,
        supabaseColumns: [],
        contextColumns: [],
        mappedColumns: [],
        columnMapping: {},
        contextMapping: {},
      });
      setIsImported(false);
      return;
    }

    // Reset import state when table changes
    setIsImported(false);

    // Fetch categorized columns from the backend
    try {
      const categorized = await integrationsApi.getCategorizedColumns(
        value.integrationId,
        tableName
      );

      // Convert context columns to ContextColumnConfig format
      const contextCols: ContextColumnConfig[] = categorized.context.map((col) => ({
        columnName: col.column_name,
        contextKey: col.column_name,
        dataType: col.data_type,
        isNullable: col.is_nullable,
      }));

      onChange({
        ...value,
        tableName,
        supabaseColumns: columns,
        contextColumns: contextCols,
        mappedColumns: categorized.mapped,
        // Reset mappings when table changes
        columnMapping: {},
        contextMapping: contextCols.reduce((acc, col) => {
          acc[col.columnName] = col.contextKey;
          return acc;
        }, {} as Record<string, string>),
      });
    } catch (err) {
      console.error("Failed to fetch categorized columns:", err);
      // Fall back to using all columns as mapped
      onChange({
        ...value,
        tableName,
        supabaseColumns: columns,
        contextColumns: [],
        mappedColumns: columns.filter((c) => !isAutoGeneratedColumn(c.column_name)),
        columnMapping: {},
        contextMapping: {},
      });
    }
  }, [value, onChange]);

  const handleContextColumnsChange = useCallback((contextColumns: ContextColumnConfig[]) => {
    // Update both contextColumns and contextMapping
    const newContextMapping = contextColumns.reduce((acc, col) => {
      acc[col.columnName] = col.contextKey;
      return acc;
    }, {} as Record<string, string>);

    onChange({
      ...value,
      contextColumns,
      contextMapping: newContextMapping,
    });
  }, [value, onChange]);

  const handleMoveToMapped = useCallback((columnName: string) => {
    // Find the column in contextColumns and move to mappedColumns
    const contextCol = value.contextColumns.find((c) => c.columnName === columnName);
    if (!contextCol) return;

    const originalColumn = value.supabaseColumns.find((c) => c.column_name === columnName);
    if (!originalColumn) return;

    // Remove from context, add to mapped
    const newContextColumns = value.contextColumns.filter((c) => c.columnName !== columnName);
    const newMappedColumns = [...value.mappedColumns, originalColumn];

    // Update context mapping
    const newContextMapping = { ...value.contextMapping };
    delete newContextMapping[columnName];

    onChange({
      ...value,
      contextColumns: newContextColumns,
      mappedColumns: newMappedColumns,
      contextMapping: newContextMapping,
    });
  }, [value, onChange]);

  const handleImportConfirm = () => {
    if (onImportSchema) {
      onImportSchema(value.mappedColumns);
      setIsImported(true);
    }
    setShowImportConfirmation(false);
  };

  const getIntegrationIcon = (type: string) => {
    switch (type) {
      case "supabase":
        return <Database className="w-4 h-4 text-green-600" />;
      case "webhook":
        return <Webhook className="w-4 h-4 text-blue-600" />;
      default:
        return null;
    }
  };

  const selectedIntegration = integrations.find(
    (i) => i.id === value.integrationId
  );

  return (
    <Card>
      <CardHeader>
        <CardTitle>Data Destination</CardTitle>
        <CardDescription>
          Choose where imported data should be automatically sent
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Integration selector */}
        <div className="space-y-2">
          <Label htmlFor="integration-select">Integration</Label>
          {isLoading ? (
            <div className="flex items-center gap-2 text-gray-500 text-sm py-2">
              <Loader2 className="w-4 h-4 animate-spin" />
              Loading integrations...
            </div>
          ) : (
            <Select
              value={value.integrationId || "__none__"}
              onValueChange={handleIntegrationChange}
            >
              <SelectTrigger id="integration-select">
                <SelectValue placeholder="Select an integration" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="__none__">
                  <span className="text-gray-500">
                    No integration (manual export only)
                  </span>
                </SelectItem>
                {integrations
                  .filter((integration) => integration.id) // Filter out any with empty IDs
                  .map((integration) => (
                    <SelectItem key={integration.id} value={integration.id}>
                      <div className="flex items-center gap-2">
                        {getIntegrationIcon(integration.type)}
                        <span>{integration.name}</span>
                        <Badge
                          variant="secondary"
                          className="ml-1 text-xs capitalize"
                        >
                          {integration.type}
                        </Badge>
                      </div>
                    </SelectItem>
                  ))}
              </SelectContent>
            </Select>
          )}

          {integrations.length === 0 && !isLoading && (
            <p className="text-sm text-gray-500">
              No integrations configured.{" "}
              <Link
                href="/settings/integrations"
                className="text-blue-600 hover:text-blue-800"
              >
                <Plus className="inline w-3 h-3" /> Add one in Settings
              </Link>
            </p>
          )}
        </div>

        {/* Supabase table picker */}
        {selectedIntegration?.type === "supabase" && value.integrationId && (
          <div className="pt-2 border-t space-y-4">
            <SupabaseTablePicker
              integrationId={value.integrationId}
              selectedTable={value.tableName}
              onTableSelect={handleTableSelect}
            />

            {/* Import schema button */}
            {value.supabaseColumns.length > 0 && onImportSchema && (
              <div className="space-y-3">
                <SchemaPreview
                  fromCsvColumns={value.mappedColumns}
                  fromAppColumns={value.contextColumns.map((c) => ({
                    column_name: c.columnName,
                    data_type: c.dataType,
                    is_nullable: c.isNullable,
                  }))}
                  autoGeneratedColumns={getAutoGeneratedColumns(value.supabaseColumns)}
                  isImported={isImported}
                />

                <div className="flex justify-end">
                  <Button
                    type="button"
                    size="sm"
                    onClick={() => setShowImportConfirmation(true)}
                  >
                    <Download className="w-4 h-4 mr-2" />
                    {isImported ? "Re-import Schema" : "Import Schema"}
                  </Button>
                </div>

                <ImportConfirmationModal
                  open={showImportConfirmation}
                  onOpenChange={setShowImportConfirmation}
                  tableName={value.tableName || ""}
                  fromCsvColumns={value.mappedColumns}
                  fromAppColumns={value.contextColumns.map((c) => ({
                    column_name: c.columnName,
                    data_type: c.dataType,
                    is_nullable: c.isNullable,
                  }))}
                  hasExistingColumns={hasExistingColumns || false}
                  onConfirm={handleImportConfirm}
                />

                {isImported && (
                  <div className="text-sm text-gray-600 bg-gray-50 p-3 rounded-lg border">
                    Next: Configure column mapping in the <strong>Columns</strong> tab
                  </div>
                )}
              </div>
            )}

            {/* Context columns section */}
            {value.tableName && value.supabaseColumns.length > 0 && (
              <div className="pt-4 border-t">
                <ContextColumnsSection
                  columns={value.contextColumns}
                  onChange={handleContextColumnsChange}
                  availableColumns={value.supabaseColumns.filter(
                    (c) => !isAutoGeneratedColumn(c.column_name)
                  )}
                  onMoveToMapped={handleMoveToMapped}
                />
              </div>
            )}
          </div>
        )}

        {/* Webhook info */}
        {selectedIntegration?.type === "webhook" && (
          <div className="pt-2 border-t">
            <Alert>
              <Webhook className="h-4 w-4" />
              <AlertDescription>
                Imported data will be POSTed to your webhook endpoint with an
                HMAC signature for verification.
              </AlertDescription>
            </Alert>
          </div>
        )}

        {/* Help text when no integration selected */}
        {!value.integrationId && !isLoading && integrations.length > 0 && (
          <p className="text-sm text-gray-500">
            Select an integration to automatically send imported data to
            Supabase or a webhook endpoint.
          </p>
        )}
      </CardContent>
    </Card>
  );
}
