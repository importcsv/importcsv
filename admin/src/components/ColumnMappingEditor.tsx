"use client";

import { useState, useEffect, useMemo, useRef } from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Label } from "@/components/ui/label";
import { Check, AlertTriangle, MinusCircle } from "lucide-react";
import { SupabaseColumnSchema } from "@/utils/apiClient";
import { ImporterField } from "@/components/AddColumnForm";

// Auto-generated columns to hide from mapping UI
const AUTO_GENERATED_COLUMNS = ["id", "created_at", "updated_at", "deleted_at"];

export interface ColumnMapping {
  importerField: string;
  tableColumn: string | null; // null means "ignore"
  status: "mapped" | "ignored" | "unmapped";
}

export interface ColumnMappingResult {
  columnMapping: Record<string, string>;
  ignoredColumns: string[];
  isValid: boolean;
  errors: string[];
}

interface ColumnMappingEditorProps {
  importerFields: ImporterField[];
  tableColumns: SupabaseColumnSchema[];
  initialMapping?: Record<string, string>;
  onChange: (result: ColumnMappingResult) => void;
}

function isAutoGenerated(columnName: string): boolean {
  return AUTO_GENERATED_COLUMNS.includes(columnName.toLowerCase());
}

function autoMapColumns(
  importerFields: ImporterField[],
  tableColumns: SupabaseColumnSchema[]
): Map<string, string> {
  const mapping = new Map<string, string>();
  const usedTableColumns = new Set<string>();

  // Get mappable table columns (exclude auto-generated)
  const mappableColumns = tableColumns.filter(
    (col) => !isAutoGenerated(col.column_name)
  );

  for (const field of importerFields) {
    // Try exact match first
    const exactMatch = mappableColumns.find(
      (col) =>
        col.column_name === field.name && !usedTableColumns.has(col.column_name)
    );
    if (exactMatch) {
      mapping.set(field.name, exactMatch.column_name);
      usedTableColumns.add(exactMatch.column_name);
      continue;
    }

    // Try case-insensitive match
    const caseInsensitiveMatch = mappableColumns.find(
      (col) =>
        col.column_name.toLowerCase() === field.name.toLowerCase() &&
        !usedTableColumns.has(col.column_name)
    );
    if (caseInsensitiveMatch) {
      mapping.set(field.name, caseInsensitiveMatch.column_name);
      usedTableColumns.add(caseInsensitiveMatch.column_name);
    }
  }

  return mapping;
}

export function ColumnMappingEditor({
  importerFields,
  tableColumns,
  initialMapping = {},
  onChange,
}: ColumnMappingEditorProps) {
  // Mappable columns (exclude auto-generated)
  const mappableTableColumns = useMemo(
    () => tableColumns.filter((col) => !isAutoGenerated(col.column_name)),
    [tableColumns]
  );

  // Initialize mappings: use initial, then auto-map what we can
  const [mappings, setMappings] = useState<Map<string, string | null>>(() => {
    const map = new Map<string, string | null>();

    // Start with auto-mapping
    const autoMapped = autoMapColumns(importerFields, tableColumns);

    // Apply initial mapping on top (if provided)
    for (const field of importerFields) {
      if (initialMapping[field.name]) {
        map.set(field.name, initialMapping[field.name]);
      } else if (autoMapped.has(field.name)) {
        map.set(field.name, autoMapped.get(field.name)!);
      }
      // Leave unmapped fields undefined (not in map)
    }

    return map;
  });

  // Track explicitly ignored columns
  const [ignoredColumns, setIgnoredColumns] = useState<Set<string>>(new Set());

  // Calculate which table columns are already used
  const usedTableColumns = useMemo(() => {
    const used = new Set<string>();
    mappings.forEach((tableCol) => {
      if (tableCol) used.add(tableCol);
    });
    return used;
  }, [mappings]);

  // Find unmapped NOT NULL table columns
  const unmappedRequiredColumns = useMemo(() => {
    return mappableTableColumns.filter(
      (col) => !col.is_nullable && !usedTableColumns.has(col.column_name)
    );
  }, [mappableTableColumns, usedTableColumns]);

  // Find unmapped nullable table columns (for info)
  const unmappedOptionalColumns = useMemo(() => {
    return mappableTableColumns.filter(
      (col) => col.is_nullable && !usedTableColumns.has(col.column_name)
    );
  }, [mappableTableColumns, usedTableColumns]);

  // Calculate validation state
  const validationResult = useMemo((): ColumnMappingResult => {
    const errors: string[] = [];
    const columnMapping: Record<string, string> = {};
    const ignored: string[] = [];

    for (const field of importerFields) {
      const tableCol = mappings.get(field.name);

      if (tableCol) {
        columnMapping[field.name] = tableCol;
      } else if (ignoredColumns.has(field.name)) {
        ignored.push(field.name);
      } else {
        errors.push(`"${field.display_name}" must be mapped or ignored`);
      }
    }

    // Warn about unmapped required columns
    for (const col of unmappedRequiredColumns) {
      errors.push(
        `Table column "${col.column_name}" is required but has no source`
      );
    }

    return {
      columnMapping,
      ignoredColumns: ignored,
      isValid: errors.length === 0,
      errors,
    };
  }, [importerFields, mappings, ignoredColumns, unmappedRequiredColumns]);

  // Track previous result to avoid infinite loops
  const prevResultRef = useRef<string>("");

  // Notify parent of changes only when values actually change
  useEffect(() => {
    const resultKey = JSON.stringify({
      columnMapping: validationResult.columnMapping,
      ignoredColumns: validationResult.ignoredColumns,
    });
    if (resultKey !== prevResultRef.current) {
      prevResultRef.current = resultKey;
      onChange(validationResult);
    }
  }, [validationResult, onChange]);

  const handleMappingChange = (fieldName: string, value: string) => {
    const newMappings = new Map(mappings);
    const newIgnored = new Set(ignoredColumns);

    if (value === "__ignore__") {
      newMappings.delete(fieldName);
      newIgnored.add(fieldName);
    } else if (value === "__none__") {
      newMappings.delete(fieldName);
      newIgnored.delete(fieldName);
    } else {
      newMappings.set(fieldName, value);
      newIgnored.delete(fieldName);
    }

    setMappings(newMappings);
    setIgnoredColumns(newIgnored);
  };

  const getFieldStatus = (
    fieldName: string
  ): "mapped" | "ignored" | "unmapped" => {
    if (mappings.has(fieldName)) return "mapped";
    if (ignoredColumns.has(fieldName)) return "ignored";
    return "unmapped";
  };

  const getStatusIcon = (status: "mapped" | "ignored" | "unmapped") => {
    switch (status) {
      case "mapped":
        return <Check className="h-4 w-4 text-green-600" />;
      case "ignored":
        return <MinusCircle className="h-4 w-4 text-gray-400" />;
      case "unmapped":
        return <AlertTriangle className="h-4 w-4 text-amber-500" />;
    }
  };

  const getStatusLabel = (status: "mapped" | "ignored" | "unmapped") => {
    switch (status) {
      case "mapped":
        return "Mapped";
      case "ignored":
        return "Ignored";
      case "unmapped":
        return "Unmapped";
    }
  };

  return (
    <div className="space-y-4">
      <div className="space-y-1">
        <Label className="text-sm font-medium">Column Mapping</Label>
        <p className="text-xs text-muted-foreground">
          Map your importer columns to the destination table columns
        </p>
      </div>

      {/* Mapping table */}
      <div className="border rounded-lg overflow-hidden">
        <div className="bg-muted/50 px-4 py-2 border-b grid grid-cols-[1fr_1fr_80px] gap-4 text-xs font-medium text-muted-foreground">
          <span>Your Column</span>
          <span>Table Column</span>
          <span className="text-center">Status</span>
        </div>

        <div className="divide-y">
          {importerFields.map((field) => {
            const status = getFieldStatus(field.name);
            const currentValue = mappings.get(field.name);

            return (
              <div
                key={field.name}
                className="px-4 py-3 grid grid-cols-[1fr_1fr_80px] gap-4 items-center"
              >
                {/* Importer field name */}
                <div>
                  <span className="font-mono text-sm">{field.name}</span>
                  {field.display_name !== field.name && (
                    <span className="text-xs text-muted-foreground ml-2">
                      ({field.display_name})
                    </span>
                  )}
                </div>

                {/* Table column selector */}
                <Select
                  value={
                    currentValue ||
                    (ignoredColumns.has(field.name) ? "__ignore__" : "__none__")
                  }
                  onValueChange={(value) =>
                    handleMappingChange(field.name, value)
                  }
                >
                  <SelectTrigger className="h-9">
                    <SelectValue placeholder="Select column..." />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="__none__">
                      <span className="text-muted-foreground">
                        — Select —
                      </span>
                    </SelectItem>
                    <SelectItem value="__ignore__">
                      <span className="text-muted-foreground flex items-center gap-2">
                        <MinusCircle className="h-3 w-3" />
                        Ignore this column
                      </span>
                    </SelectItem>
                    {mappableTableColumns
                      .filter(
                        (col) =>
                          !usedTableColumns.has(col.column_name) ||
                          col.column_name === currentValue
                      )
                      .map((col) => (
                        <SelectItem key={col.column_name} value={col.column_name}>
                          <span className="font-mono">{col.column_name}</span>
                          {!col.is_nullable && (
                            <Badge
                              variant="outline"
                              className="ml-2 text-[10px] px-1"
                            >
                              required
                            </Badge>
                          )}
                        </SelectItem>
                      ))}
                  </SelectContent>
                </Select>

                {/* Status indicator */}
                <div className="flex items-center justify-center gap-1">
                  {getStatusIcon(status)}
                  <span className="text-xs text-muted-foreground">
                    {getStatusLabel(status)}
                  </span>
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Unmapped table columns info */}
      {(unmappedRequiredColumns.length > 0 ||
        unmappedOptionalColumns.length > 0) && (
        <div className="space-y-2">
          {unmappedRequiredColumns.length > 0 && (
            <Alert variant="destructive">
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                <strong>Required columns without source:</strong>{" "}
                {unmappedRequiredColumns.map((c) => c.column_name).join(", ")}
                <br />
                <span className="text-xs">
                  These columns are NOT NULL — inserts will fail without values.
                </span>
              </AlertDescription>
            </Alert>
          )}

          {unmappedOptionalColumns.length > 0 && (
            <p className="text-xs text-muted-foreground">
              <strong>Optional columns without source:</strong>{" "}
              {unmappedOptionalColumns.map((c) => c.column_name).join(", ")}
              {" — "}these will be null/default.
            </p>
          )}
        </div>
      )}
    </div>
  );
}
