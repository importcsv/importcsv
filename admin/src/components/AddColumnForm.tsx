'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { ChevronRight, Plus } from 'lucide-react';
import ValidationBuilder, { Validator } from './ValidationBuilder';
import TransformationBuilder, { Transformation } from './TransformationBuilder';

// Define the ImporterField interface (cleaned up to match what frontend actually uses)
export interface ImporterField {
  name: string;                      // Column name as in CSV
  display_name: string;              // Display name for users
  type: string;                      // text, number, date, email, phone, boolean, select, custom_regex
  validators?: Validator[];          // Array of validation rules
  transformations?: Transformation[]; // Array of transformation rules
  options?: string[];                // Options for select fields
  validation_format?: string;        // For select (comma-separated) or custom_regex (pattern)
  template?: string;                 // For boolean type (e.g., "true/false", "yes/no", "1/0")
}

interface AddColumnFormProps {
  onAddColumn: (field: ImporterField) => void;
  existingFields: ImporterField[];
  className?: string;
  initialField?: ImporterField; // For editing existing columns
  submitButtonText?: string; // Custom text for submit button
}

export default function AddColumnForm({
  onAddColumn,
  existingFields,
  className = '',
  initialField,
  submitButtonText = 'Add Column'
}: AddColumnFormProps) {
  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});
  const [newField, setNewField] = useState<ImporterField>(initialField || {
    name: '',
    display_name: '',
    type: 'text',
    validators: [],
    transformations: [],
    options: []
  });
  const [validationOpen, setValidationOpen] = useState(false);
  const [transformationOpen, setTransformationOpen] = useState(false);
  
  // Helper function to generate display name from column name
  const generateDisplayName = (columnName: string): string => {
    // Convert snake_case, kebab-case, or camelCase to Title Case
    return columnName
      .replace(/[-_]/g, ' ') // Replace - and _ with spaces
      .replace(/([a-z])([A-Z])/g, '$1 $2') // Add space before capital letters in camelCase
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ')
      .trim();
  };

  // Handle field input changes
  const handleFieldInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    
    if (name === 'name') {
      // Remove spaces from column name
      const cleanedName = value.replace(/\s/g, '');
      
      // Auto-populate display_name if it's empty or was auto-generated
      const currentDisplayName = newField.display_name;
      const wasAutoGenerated = currentDisplayName === generateDisplayName(newField.name);
      
      setNewField(prev => ({
        ...prev,
        name: cleanedName,
        // Only auto-update display_name if it's empty or was previously auto-generated
        display_name: (!currentDisplayName || wasAutoGenerated) 
          ? generateDisplayName(cleanedName) 
          : currentDisplayName
      }));
    } else {
      setNewField(prev => ({
        ...prev,
        [name]: value
      }));
    }
  };

  // Handle field type change
  const handleTypeChange = (value: string) => {
    setNewField(prev => ({
      ...prev,
      type: value,
      validation_format: '',
      template: value === 'boolean' ? 'true/false' : ''
    }));
  };

  // Add field handler
  const addFieldHandler = () => {
    // Reset previous errors
    const errors: Record<string, string> = {};
    let hasErrors = false;
    
    // Basic validation
    if (!newField.name) {
      errors.name = 'Column name is required';
      hasErrors = true;
    }
    
    if (!newField.type) {
      errors.type = 'Column type is required';
      hasErrors = true;
    }
    
    // Check for duplicate field names (skip this check when editing if name hasn't changed)
    if (existingFields.some(f => f.name === newField.name)) {
      errors.name = `Column name '${newField.name}' already exists`;
      hasErrors = true;
    }
    
    // For select type, ensure options are set
    if (newField.type === 'select' && (!newField.options || newField.options.length === 0)) {
      // Check if validation_format has options (backward compatibility)
      if (!newField.validation_format) {
        errors.validation_format = 'Please provide options for the select field';
        hasErrors = true;
      } else {
        // Convert validation_format to options array
        newField.options = newField.validation_format.split(',').map((o: string) => o.trim());
      }
    }
    
    // For custom regex type, ensure validation_format is set and is a valid regex
    if (newField.type === 'custom_regex') {
      if (!newField.validation_format) {
        errors.validation_format = 'Please provide a regular expression pattern';
        hasErrors = true;
      } else {
        // Validate the regex pattern
        try {
          new RegExp(newField.validation_format);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Invalid pattern';
          errors.validation_format = `Invalid regular expression: ${errorMessage}`;
          hasErrors = true;
        }
      }
    }
    
    // If there are errors, update state and return
    if (hasErrors) {
      setFieldErrors(errors);
      return;
    }
    
    // Call the parent handler
    onAddColumn({ ...newField });
    
    // Reset the form
    setNewField({
      name: '',
      display_name: '',
      type: 'text',
      validators: [],
      transformations: [],
      options: []
    });
    
    // Clear any errors
    setFieldErrors({});
  };

  const validatorCount = newField.validators?.length ?? 0;
  const transformationCount = newField.transformations?.length ?? 0;

  return (
    <div className={`space-y-3 ${className}`}>
      {/* Basic Info Section - Always visible */}
      <div className="rounded-lg border border-border bg-card">
        <div className="flex items-center justify-between px-4 py-3 border-b border-border/50">
          <span className="text-sm font-medium">Basic Info</span>
          {newField.name && (
            <span className="text-xs text-green-600 font-medium">Ready</span>
          )}
        </div>
        <div className="p-4 space-y-4">
          {/* Grouped name fields */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {/* Column Name */}
            <div className="space-y-1.5">
              <Label htmlFor="fieldName" className="text-xs font-medium text-muted-foreground uppercase tracking-wide">
                Column Name
              </Label>
              <Input
                id="fieldName"
                name="name"
                value={newField.name}
                onChange={handleFieldInputChange}
                placeholder="e.g. email, first_name"
                className={`h-9 ${fieldErrors.name ? 'border-red-500' : ''}`}
                required
              />
              {fieldErrors.name ? (
                <p className="text-xs text-red-500">{fieldErrors.name}</p>
              ) : (
                <p className="text-xs text-muted-foreground">Exact name from CSV file</p>
              )}
            </div>

            {/* Display Name */}
            <div className="space-y-1.5">
              <Label htmlFor="fieldDisplayName" className="text-xs font-medium text-muted-foreground uppercase tracking-wide">
                Display Name
              </Label>
              <Input
                id="fieldDisplayName"
                name="display_name"
                value={newField.display_name}
                onChange={handleFieldInputChange}
                placeholder="e.g. Email Address"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">Shown to users (optional)</p>
            </div>
          </div>

          {/* Format selector */}
          <div className="space-y-1.5">
            <Label htmlFor="fieldType" className="text-xs font-medium text-muted-foreground uppercase tracking-wide">
              Data Format
            </Label>
            <Select
              value={newField.type}
              onValueChange={handleTypeChange}
            >
              <SelectTrigger id="fieldType" className={`h-9 ${fieldErrors.type ? 'border-red-500' : ''}`}>
                <SelectValue placeholder="Select a format" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="text">Text (any value)</SelectItem>
                <SelectItem value="number">Number</SelectItem>
                <SelectItem value="date">Date</SelectItem>
                <SelectItem value="email">Email</SelectItem>
                <SelectItem value="phone">Phone Number</SelectItem>
                <SelectItem value="boolean">Boolean</SelectItem>
                <SelectItem value="select">Select (options)</SelectItem>
                <SelectItem value="custom_regex">Custom Regular Expression</SelectItem>
              </SelectContent>
            </Select>
            {fieldErrors.type && (
              <p className="text-xs text-red-500">{fieldErrors.type}</p>
            )}
          </div>

          {/* Options for Select type */}
          {newField.type === 'select' && (
            <div className="space-y-1.5">
              <Label htmlFor="fieldOptions" className="text-xs font-medium text-muted-foreground uppercase tracking-wide">
                Options
              </Label>
              <Input
                id="fieldOptions"
                name="validation_format"
                value={newField.validation_format || ''}
                onChange={handleFieldInputChange}
                placeholder="blue,red,yellow,white"
                className={`h-9 ${fieldErrors.validation_format ? 'border-red-500' : ''}`}
                required
              />
              {fieldErrors.validation_format ? (
                <p className="text-xs text-red-500">{fieldErrors.validation_format}</p>
              ) : (
                <p className="text-xs text-muted-foreground">Comma separated list of options</p>
              )}

              {/* Preview badges */}
              {newField.validation_format && (
                <div className="mt-2 p-3 bg-muted/50 rounded-md border border-border/50">
                  <p className="text-xs font-medium text-muted-foreground mb-2">Preview:</p>
                  <div className="flex flex-wrap gap-1.5">
                    {newField.validation_format.split(',').map((option: string, index: number) => (
                      <span
                        key={index}
                        className="px-2 py-0.5 bg-primary/10 text-primary rounded text-xs font-medium"
                      >
                        {option.trim()}
                      </span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Template for Boolean type */}
          {newField.type === 'boolean' && (
            <div className="space-y-1.5">
              <Label htmlFor="fieldTemplate" className="text-xs font-medium text-muted-foreground uppercase tracking-wide">
                Boolean Format
              </Label>
              <Select
                value={newField.template || 'true/false'}
                onValueChange={(value) => setNewField(prev => ({
                  ...prev,
                  template: value
                }))}
              >
                <SelectTrigger id="fieldTemplate" className="h-9">
                  <SelectValue placeholder="Choose template" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="true/false">true/false</SelectItem>
                  <SelectItem value="yes/no">yes/no</SelectItem>
                  <SelectItem value="1/0">1/0</SelectItem>
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">Format for boolean values in CSV</p>
            </div>
          )}

          {/* Custom Regular Expression */}
          {newField.type === 'custom_regex' && (
            <div className="space-y-1.5">
              <Label htmlFor="fieldRegex" className="text-xs font-medium text-muted-foreground uppercase tracking-wide">
                Regular Expression
              </Label>
              <Input
                id="fieldRegex"
                name="validation_format"
                value={newField.validation_format || ''}
                onChange={handleFieldInputChange}
                placeholder="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
                className={`h-9 font-mono text-sm ${fieldErrors.validation_format ? 'border-red-500' : ''}`}
                required
              />
              {fieldErrors.validation_format ? (
                <p className="text-xs text-red-500">{fieldErrors.validation_format}</p>
              ) : (
                <p className="text-xs text-muted-foreground">Enter a valid regular expression pattern</p>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Validation Section - Collapsible */}
      <Collapsible open={validationOpen} onOpenChange={setValidationOpen}>
        <div className="rounded-lg border border-border bg-card">
          <CollapsibleTrigger className="flex items-center justify-between w-full px-4 py-3 hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2">
              <ChevronRight className={`h-4 w-4 text-muted-foreground transition-transform ${validationOpen ? 'rotate-90' : ''}`} />
              <span className="text-sm font-medium">Validation</span>
            </div>
            <div className="flex items-center gap-1.5">
              <span className={`w-2 h-2 rounded-full ${validatorCount > 0 ? 'bg-green-500' : 'bg-muted-foreground/30'}`} />
              <span className="text-xs text-muted-foreground">
                {validatorCount > 0 ? `${validatorCount} rule${validatorCount !== 1 ? 's' : ''}` : 'No rules'}
              </span>
            </div>
          </CollapsibleTrigger>
          <CollapsibleContent>
            <div className="px-4 pb-4 border-t border-border/50">
              <div className="pt-4">
                <ValidationBuilder
                  validators={newField.validators || []}
                  onChange={(validators) => {
                    setNewField(prev => ({
                      ...prev,
                      validators
                    }));
                  }}
                  fieldType={newField.type}
                />
              </div>
            </div>
          </CollapsibleContent>
        </div>
      </Collapsible>

      {/* Transformation Section - Collapsible */}
      <Collapsible open={transformationOpen} onOpenChange={setTransformationOpen}>
        <div className="rounded-lg border border-border bg-card">
          <CollapsibleTrigger className="flex items-center justify-between w-full px-4 py-3 hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2">
              <ChevronRight className={`h-4 w-4 text-muted-foreground transition-transform ${transformationOpen ? 'rotate-90' : ''}`} />
              <span className="text-sm font-medium">Transformation</span>
            </div>
            <div className="flex items-center gap-1.5">
              <span className={`w-2 h-2 rounded-full ${transformationCount > 0 ? 'bg-green-500' : 'bg-muted-foreground/30'}`} />
              <span className="text-xs text-muted-foreground">
                {transformationCount > 0 ? `${transformationCount} transform${transformationCount !== 1 ? 's' : ''}` : 'No transforms'}
              </span>
            </div>
          </CollapsibleTrigger>
          <CollapsibleContent>
            <div className="px-4 pb-4 border-t border-border/50">
              <div className="pt-4">
                <TransformationBuilder
                  transformations={newField.transformations || []}
                  onChange={(transformations) => setNewField(prev => ({ ...prev, transformations }))}
                  fieldType={newField.type}
                />
              </div>
            </div>
          </CollapsibleContent>
        </div>
      </Collapsible>

      <Button
        type="button"
        onClick={addFieldHandler}
        className="w-full h-10 font-medium"
      >
        <Plus className="h-4 w-4 mr-2" />
        {submitButtonText}
      </Button>
    </div>
  );
}
