# Supabase Column Mapping Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a column mapping UI that appears when an importer's schema doesn't match the destination Supabase table, allowing users to map or explicitly ignore columns.

**Architecture:** Create a new `ColumnMappingEditor` component that takes importer fields and table columns, auto-maps exact/case-insensitive matches, and requires explicit user action for unmapped columns. Integrate into `DestinationSelector` to show after table selection when schemas differ.

**Tech Stack:** React, TypeScript, shadcn/ui components, existing apiClient

---

## Task 1: Create ColumnMappingEditor Component

**Files:**
- Create: `admin/src/components/ColumnMappingEditor.tsx`

**Step 1: Create the component with types and auto-mapping logic**

Create `admin/src/components/ColumnMappingEditor.tsx`:

```tsx
"use client";

import { useState, useEffect, useMemo } from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Label } from "@/components/ui/label";
import { Check, AlertTriangle, MinusCircle } from "lucide-react";
import { SupabaseColumnSchema } from "@/utils/apiClient";
import { ImporterField } from "@/components/AddColumnForm";

// Auto-generated columns to hide from mapping UI
const AUTO_GENERATED_COLUMNS = ["id", "created_at", "updated_at", "deleted_at"];

export interface ColumnMapping {
  importerField: string;
  tableColumn: string | null; // null means "ignore"
  status: "mapped" | "ignored" | "unmapped";
}

export interface ColumnMappingResult {
  columnMapping: Record<string, string>;
  ignoredColumns: string[];
  isValid: boolean;
  errors: string[];
}

interface ColumnMappingEditorProps {
  importerFields: ImporterField[];
  tableColumns: SupabaseColumnSchema[];
  initialMapping?: Record<string, string>;
  onChange: (result: ColumnMappingResult) => void;
}

function isAutoGenerated(columnName: string): boolean {
  return AUTO_GENERATED_COLUMNS.includes(columnName.toLowerCase());
}

function autoMapColumns(
  importerFields: ImporterField[],
  tableColumns: SupabaseColumnSchema[]
): Map<string, string> {
  const mapping = new Map<string, string>();
  const usedTableColumns = new Set<string>();

  // Get mappable table columns (exclude auto-generated)
  const mappableColumns = tableColumns.filter(
    (col) => !isAutoGenerated(col.column_name)
  );

  for (const field of importerFields) {
    // Try exact match first
    const exactMatch = mappableColumns.find(
      (col) =>
        col.column_name === field.name && !usedTableColumns.has(col.column_name)
    );
    if (exactMatch) {
      mapping.set(field.name, exactMatch.column_name);
      usedTableColumns.add(exactMatch.column_name);
      continue;
    }

    // Try case-insensitive match
    const caseInsensitiveMatch = mappableColumns.find(
      (col) =>
        col.column_name.toLowerCase() === field.name.toLowerCase() &&
        !usedTableColumns.has(col.column_name)
    );
    if (caseInsensitiveMatch) {
      mapping.set(field.name, caseInsensitiveMatch.column_name);
      usedTableColumns.add(caseInsensitiveMatch.column_name);
    }
  }

  return mapping;
}

export function ColumnMappingEditor({
  importerFields,
  tableColumns,
  initialMapping = {},
  onChange,
}: ColumnMappingEditorProps) {
  // Mappable columns (exclude auto-generated)
  const mappableTableColumns = useMemo(
    () => tableColumns.filter((col) => !isAutoGenerated(col.column_name)),
    [tableColumns]
  );

  // Initialize mappings: use initial, then auto-map what we can
  const [mappings, setMappings] = useState<Map<string, string | null>>(() => {
    const map = new Map<string, string | null>();

    // Start with auto-mapping
    const autoMapped = autoMapColumns(importerFields, tableColumns);

    // Apply initial mapping on top (if provided)
    for (const field of importerFields) {
      if (initialMapping[field.name]) {
        map.set(field.name, initialMapping[field.name]);
      } else if (autoMapped.has(field.name)) {
        map.set(field.name, autoMapped.get(field.name)!);
      }
      // Leave unmapped fields undefined (not in map)
    }

    return map;
  });

  // Track explicitly ignored columns
  const [ignoredColumns, setIgnoredColumns] = useState<Set<string>>(new Set());

  // Calculate which table columns are already used
  const usedTableColumns = useMemo(() => {
    const used = new Set<string>();
    mappings.forEach((tableCol) => {
      if (tableCol) used.add(tableCol);
    });
    return used;
  }, [mappings]);

  // Find unmapped NOT NULL table columns
  const unmappedRequiredColumns = useMemo(() => {
    return mappableTableColumns.filter(
      (col) => !col.is_nullable && !usedTableColumns.has(col.column_name)
    );
  }, [mappableTableColumns, usedTableColumns]);

  // Find unmapped nullable table columns (for info)
  const unmappedOptionalColumns = useMemo(() => {
    return mappableTableColumns.filter(
      (col) => col.is_nullable && !usedTableColumns.has(col.column_name)
    );
  }, [mappableTableColumns, usedTableColumns]);

  // Calculate validation state
  const validationResult = useMemo((): ColumnMappingResult => {
    const errors: string[] = [];
    const columnMapping: Record<string, string> = {};
    const ignored: string[] = [];

    for (const field of importerFields) {
      const tableCol = mappings.get(field.name);

      if (tableCol) {
        columnMapping[field.name] = tableCol;
      } else if (ignoredColumns.has(field.name)) {
        ignored.push(field.name);
      } else {
        errors.push(`"${field.display_name}" must be mapped or ignored`);
      }
    }

    // Warn about unmapped required columns
    for (const col of unmappedRequiredColumns) {
      errors.push(
        `Table column "${col.column_name}" is required but has no source`
      );
    }

    return {
      columnMapping,
      ignoredColumns: ignored,
      isValid: errors.length === 0,
      errors,
    };
  }, [importerFields, mappings, ignoredColumns, unmappedRequiredColumns]);

  // Notify parent of changes
  useEffect(() => {
    onChange(validationResult);
  }, [validationResult, onChange]);

  const handleMappingChange = (fieldName: string, value: string) => {
    const newMappings = new Map(mappings);
    const newIgnored = new Set(ignoredColumns);

    if (value === "__ignore__") {
      newMappings.delete(fieldName);
      newIgnored.add(fieldName);
    } else if (value === "__none__") {
      newMappings.delete(fieldName);
      newIgnored.delete(fieldName);
    } else {
      newMappings.set(fieldName, value);
      newIgnored.delete(fieldName);
    }

    setMappings(newMappings);
    setIgnoredColumns(newIgnored);
  };

  const getFieldStatus = (
    fieldName: string
  ): "mapped" | "ignored" | "unmapped" => {
    if (mappings.has(fieldName)) return "mapped";
    if (ignoredColumns.has(fieldName)) return "ignored";
    return "unmapped";
  };

  const getStatusIcon = (status: "mapped" | "ignored" | "unmapped") => {
    switch (status) {
      case "mapped":
        return <Check className="h-4 w-4 text-green-600" />;
      case "ignored":
        return <MinusCircle className="h-4 w-4 text-gray-400" />;
      case "unmapped":
        return <AlertTriangle className="h-4 w-4 text-amber-500" />;
    }
  };

  const getStatusLabel = (status: "mapped" | "ignored" | "unmapped") => {
    switch (status) {
      case "mapped":
        return "Mapped";
      case "ignored":
        return "Ignored";
      case "unmapped":
        return "Unmapped";
    }
  };

  return (
    <div className="space-y-4">
      <div className="space-y-1">
        <Label className="text-sm font-medium">Column Mapping</Label>
        <p className="text-xs text-muted-foreground">
          Map your importer columns to the destination table columns
        </p>
      </div>

      {/* Mapping table */}
      <div className="border rounded-lg overflow-hidden">
        <div className="bg-muted/50 px-4 py-2 border-b grid grid-cols-[1fr,auto,1fr,80px] gap-2 text-xs font-medium text-muted-foreground">
          <span>Your Column</span>
          <span></span>
          <span>Table Column</span>
          <span className="text-center">Status</span>
        </div>

        <div className="divide-y">
          {importerFields.map((field) => {
            const status = getFieldStatus(field.name);
            const currentValue = mappings.get(field.name);

            return (
              <div
                key={field.name}
                className="px-4 py-3 grid grid-cols-[1fr,auto,1fr,80px] gap-2 items-center"
              >
                {/* Importer field name */}
                <div>
                  <span className="font-mono text-sm">{field.name}</span>
                  {field.display_name !== field.name && (
                    <span className="text-xs text-muted-foreground ml-2">
                      ({field.display_name})
                    </span>
                  )}
                </div>

                {/* Arrow */}
                <span className="text-muted-foreground">→</span>

                {/* Table column selector */}
                <Select
                  value={
                    currentValue ||
                    (ignoredColumns.has(field.name) ? "__ignore__" : "__none__")
                  }
                  onValueChange={(value) =>
                    handleMappingChange(field.name, value)
                  }
                >
                  <SelectTrigger className="h-9">
                    <SelectValue placeholder="Select column..." />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="__none__">
                      <span className="text-muted-foreground">
                        — Select —
                      </span>
                    </SelectItem>
                    <SelectItem value="__ignore__">
                      <span className="text-muted-foreground flex items-center gap-2">
                        <MinusCircle className="h-3 w-3" />
                        Ignore this column
                      </span>
                    </SelectItem>
                    {mappableTableColumns
                      .filter(
                        (col) =>
                          !usedTableColumns.has(col.column_name) ||
                          col.column_name === currentValue
                      )
                      .map((col) => (
                        <SelectItem key={col.column_name} value={col.column_name}>
                          <span className="font-mono">{col.column_name}</span>
                          {!col.is_nullable && (
                            <Badge
                              variant="outline"
                              className="ml-2 text-[10px] px-1"
                            >
                              required
                            </Badge>
                          )}
                        </SelectItem>
                      ))}
                  </SelectContent>
                </Select>

                {/* Status indicator */}
                <div className="flex items-center justify-center gap-1">
                  {getStatusIcon(status)}
                  <span className="text-xs text-muted-foreground">
                    {getStatusLabel(status)}
                  </span>
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Unmapped table columns info */}
      {(unmappedRequiredColumns.length > 0 ||
        unmappedOptionalColumns.length > 0) && (
        <div className="space-y-2">
          {unmappedRequiredColumns.length > 0 && (
            <Alert variant="destructive">
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                <strong>Required columns without source:</strong>{" "}
                {unmappedRequiredColumns.map((c) => c.column_name).join(", ")}
                <br />
                <span className="text-xs">
                  These columns are NOT NULL — inserts will fail without values.
                </span>
              </AlertDescription>
            </Alert>
          )}

          {unmappedOptionalColumns.length > 0 && (
            <p className="text-xs text-muted-foreground">
              <strong>Optional columns without source:</strong>{" "}
              {unmappedOptionalColumns.map((c) => c.column_name).join(", ")}
              {" — "}these will be null/default.
            </p>
          )}
        </div>
      )}
    </div>
  );
}
```

**Step 2: Verify component compiles**

Run: `cd admin && npm run build 2>&1 | head -50`
Expected: No TypeScript errors related to ColumnMappingEditor

**Step 3: Commit**

```bash
git add admin/src/components/ColumnMappingEditor.tsx
git commit -m "feat(admin): add ColumnMappingEditor component for schema mapping"
```

---

## Task 2: Update DestinationSelector Props

**Files:**
- Modify: `admin/src/components/DestinationSelector.tsx:62-67`

**Step 1: Add importerFields prop to DestinationSelectorProps**

In `admin/src/components/DestinationSelector.tsx`, update the props interface around line 62:

```tsx
interface DestinationSelectorProps {
  value: DestinationConfig;
  onChange: (config: DestinationConfig) => void;
  onImportSchema?: (columns: SupabaseColumnSchema[]) => void;
  hasExistingColumns?: boolean;
  importerFields?: ImporterField[];  // ADD THIS LINE
  schemaSource?: "csv" | "manual" | "database";  // ADD THIS LINE
}
```

**Step 2: Add import for ImporterField at top of file**

Add to imports around line 31-35:

```tsx
import { ImporterField } from "@/components/AddColumnForm";
```

**Step 3: Update function signature to destructure new props**

Update around line 69:

```tsx
export function DestinationSelector({
  value,
  onChange,
  onImportSchema,
  hasExistingColumns = false,
  importerFields = [],  // ADD THIS
  schemaSource,  // ADD THIS
}: DestinationSelectorProps) {
```

**Step 4: Verify no TypeScript errors**

Run: `cd admin && npm run build 2>&1 | head -30`
Expected: Build succeeds (props are optional, so existing usages still work)

**Step 5: Commit**

```bash
git add admin/src/components/DestinationSelector.tsx
git commit -m "feat(admin): add importerFields and schemaSource props to DestinationSelector"
```

---

## Task 3: Integrate ColumnMappingEditor into DestinationSelector

**Files:**
- Modify: `admin/src/components/DestinationSelector.tsx:340-390`

**Step 1: Add import for ColumnMappingEditor**

Add to imports at top of file:

```tsx
import { ColumnMappingEditor, ColumnMappingResult } from "@/components/ColumnMappingEditor";
```

**Step 2: Add state for tracking mapping validity**

Add after the existing state declarations (around line 79):

```tsx
const [mappingResult, setMappingResult] = useState<ColumnMappingResult | null>(null);
```

**Step 3: Add helper to determine if mapping UI should show**

Add after the existing helper functions (around line 265):

```tsx
// Determine if we should show the column mapping UI
// Show when: schema wasn't derived from the same destination table
const shouldShowMappingUI = useMemo(() => {
  if (!value.tableName || !importerFields || importerFields.length === 0) {
    return false;
  }
  // If schema came from "Connect Database" with same table, don't show
  if (schemaSource === "database" && value.tableName) {
    // Check if importer fields match table columns (same table)
    const tableColNames = new Set(
      value.supabaseColumns.map((c) => c.column_name.toLowerCase())
    );
    const allFieldsMatch = importerFields.every((f) =>
      tableColNames.has(f.name.toLowerCase())
    );
    if (allFieldsMatch) {
      return false;
    }
  }
  // For CSV/Manual schemas, or different table, show mapping UI
  return true;
}, [value.tableName, value.supabaseColumns, importerFields, schemaSource]);
```

**Step 4: Add handler for mapping changes**

Add after the existing handlers (around line 252):

```tsx
const handleMappingChange = useCallback((result: ColumnMappingResult) => {
  setMappingResult(result);
  onChange({
    ...value,
    columnMapping: result.columnMapping,
  });
}, [value, onChange]);
```

**Step 5: Add ColumnMappingEditor to the JSX**

Find the section after SupabaseTablePicker (around line 343-386) and add the mapping editor. Replace the existing section with:

```tsx
{/* Supabase table picker */}
{selectedIntegration?.type === "supabase" && value.integrationId && (
  <div className="pt-2 border-t space-y-4">
    <SupabaseTablePicker
      integrationId={value.integrationId}
      selectedTable={value.tableName}
      onTableSelect={handleTableSelect}
    />

    {/* Column mapping UI - shows when schema source differs from destination */}
    {shouldShowMappingUI && value.mappedColumns.length > 0 && (
      <div className="pt-4 border-t">
        <ColumnMappingEditor
          importerFields={importerFields}
          tableColumns={value.mappedColumns}
          initialMapping={value.columnMapping}
          onChange={handleMappingChange}
        />
      </div>
    )}

    {/* Import schema button - only show when NOT showing mapping UI */}
    {!shouldShowMappingUI && value.supabaseColumns.length > 0 && onImportSchema && (
      <div className="flex items-center justify-between p-3 bg-blue-50 rounded-lg border border-blue-100">
        <div className="text-sm">
          <p className="font-medium text-blue-900">
            {hasExistingColumns
              ? "Replace columns from table schema?"
              : "Import columns from table schema?"}
          </p>
          <p className="text-blue-700">
            {value.mappedColumns.length} importable columns, {value.contextColumns.length} context columns detected
          </p>
        </div>
        <Button
          type="button"
          size="sm"
          onClick={() => onImportSchema(value.mappedColumns)}
        >
          <Download className="w-4 h-4 mr-2" />
          Import Schema
        </Button>
      </div>
    )}

    {/* Context columns section */}
    {value.tableName && value.supabaseColumns.length > 0 && (
      <div className="pt-4 border-t">
        <ContextColumnsSection
          columns={value.contextColumns}
          onChange={handleContextColumnsChange}
          availableColumns={value.supabaseColumns.filter(
            (c) => !isAutoGeneratedColumn(c.column_name)
          )}
          onMoveToMapped={handleMoveToMapped}
        />
      </div>
    )}
  </div>
)}
```

**Step 6: Add useMemo import if not present**

Ensure useMemo is imported at the top:

```tsx
import { useState, useEffect, useCallback, useMemo } from "react";
```

**Step 7: Verify component compiles**

Run: `cd admin && npm run build 2>&1 | head -50`
Expected: Build succeeds

**Step 8: Commit**

```bash
git add admin/src/components/DestinationSelector.tsx
git commit -m "feat(admin): integrate ColumnMappingEditor into DestinationSelector"
```

---

## Task 4: Pass importerFields to DestinationSelector in New Importer Page

**Files:**
- Modify: `admin/src/app/(dashboard)/importers/new/page.tsx:464-470`

**Step 1: Update DestinationSelector usage in Step 2 (destination)**

Find the DestinationSelector in renderStep2 (around line 464) and add the new props:

```tsx
{destinationType === 'supabase' && hasSupabaseIntegration && (
  <Card>
    <CardHeader>
      <CardTitle>Supabase Configuration</CardTitle>
      <CardDescription>Select integration, table, and column mapping</CardDescription>
    </CardHeader>
    <CardContent>
      <DestinationSelector
        value={destination}
        onChange={handleDestinationChange}
        hasExistingColumns={getActiveFields().length > 0}
        importerFields={getActiveFields()}
        schemaSource={activeTab === 'database' ? 'database' : activeTab === 'upload' ? 'csv' : 'manual'}
      />
    </CardContent>
  </Card>
)}
```

**Step 2: Update DestinationSelector usage in Step 1 (Connect Database tab)**

Find the DestinationSelector in the "database" tab (around line 369) and ensure it has schemaSource:

```tsx
<DestinationSelector
  value={destination}
  onChange={handleDestinationChange}
  onImportSchema={handleImportSchemaFromDatabase}
  hasExistingColumns={fields.length > 0}
  schemaSource="database"
/>
```

**Step 3: Verify no TypeScript errors**

Run: `cd admin && npm run build 2>&1 | head -30`
Expected: Build succeeds

**Step 4: Commit**

```bash
git add admin/src/app/(dashboard)/importers/new/page.tsx
git commit -m "feat(admin): pass importerFields and schemaSource to DestinationSelector"
```

---

## Task 5: Pass importerFields to DestinationSelector in ChangeDestinationModal

**Files:**
- Modify: `admin/src/components/ChangeDestinationModal.tsx:174-180`

**Step 1: Update DestinationSelector usage**

Find the DestinationSelector (around line 174) and add importerFields prop:

```tsx
{destinationType === "supabase" && hasSupabaseIntegration && (
  <DestinationSelector
    value={config}
    onChange={setConfig}
    hasExistingColumns={importerFields.length > 0}
    importerFields={importerFields}
    schemaSource="manual"  // When changing destination, treat as manual (schema already defined)
  />
)}
```

**Step 2: Verify no TypeScript errors**

Run: `cd admin && npm run build 2>&1 | head -30`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add admin/src/components/ChangeDestinationModal.tsx
git commit -m "feat(admin): pass importerFields to DestinationSelector in ChangeDestinationModal"
```

---

## Task 6: Add Validation to Prevent Saving Invalid Mappings

**Files:**
- Modify: `admin/src/app/(dashboard)/importers/new/page.tsx:187-211`

**Step 1: Update validateStep2 to check mapping validity**

Find validateStep2 (around line 187) and update:

```tsx
// Validate step 2
const validateStep2 = (): boolean => {
  if (destinationType === 'webhook') {
    if (!webhookUrl) {
      setFormError('Please enter a webhook URL');
      return false;
    }
    if (!webhookUrl.startsWith('https://')) {
      setFormError('Webhook URL must use HTTPS');
      return false;
    }
  }

  if (destinationType === 'supabase') {
    if (!destination.integrationId) {
      setFormError('Please select a Supabase integration');
      return false;
    }
    if (!destination.tableName) {
      setFormError('Please select a destination table');
      return false;
    }

    // Check if mapping is required and valid
    const activeFields = getActiveFields();
    const needsMapping = activeTab !== 'database' ||
      !activeFields.every(f =>
        destination.supabaseColumns.some(c =>
          c.column_name.toLowerCase() === f.name.toLowerCase()
        )
      );

    if (needsMapping && activeFields.length > 0) {
      // Verify all fields are mapped or explicitly ignored
      const mappedFields = Object.keys(destination.columnMapping);
      const unmappedFields = activeFields.filter(
        f => !mappedFields.includes(f.name)
      );

      if (unmappedFields.length > 0) {
        setFormError(
          `Please map or ignore all columns: ${unmappedFields.map(f => f.display_name).join(', ')}`
        );
        return false;
      }
    }
  }

  return true;
};
```

**Step 2: Verify no TypeScript errors**

Run: `cd admin && npm run build 2>&1 | head -30`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add admin/src/app/(dashboard)/importers/new/page.tsx
git commit -m "feat(admin): add validation for column mappings in new importer flow"
```

---

## Task 7: Update DestinationConfig Interface to Track Ignored Columns

**Files:**
- Modify: `admin/src/components/DestinationSelector.tsx:48-60`

**Step 1: Add ignoredColumns to DestinationConfig**

Update the interface around line 48:

```tsx
export interface DestinationConfig {
  integrationId: string | null;
  integrationType: "supabase" | "webhook" | null;
  tableName: string | null;
  columnMapping: Record<string, string>;
  contextMapping: Record<string, string>;
  supabaseColumns: SupabaseColumnSchema[];
  contextColumns: ContextColumnConfig[];
  mappedColumns: SupabaseColumnSchema[];
  ignoredColumns: string[];  // ADD THIS LINE
  // Webhook fields
  webhookUrl?: string;
  signingSecret?: string | null;
}
```

**Step 2: Update handleMappingChange to include ignoredColumns**

Update the handler around line 252:

```tsx
const handleMappingChange = useCallback((result: ColumnMappingResult) => {
  setMappingResult(result);
  onChange({
    ...value,
    columnMapping: result.columnMapping,
    ignoredColumns: result.ignoredColumns,
  });
}, [value, onChange]);
```

**Step 3: Update all places that initialize DestinationConfig to include ignoredColumns**

In `admin/src/app/(dashboard)/importers/new/page.tsx`, update the initial state (around line 54):

```tsx
const [destination, setDestination] = useState<DestinationConfig>({
  integrationId: null,
  integrationType: null,
  tableName: null,
  columnMapping: {},
  contextMapping: {},
  supabaseColumns: [],
  contextColumns: [],
  mappedColumns: [],
  ignoredColumns: [],  // ADD THIS
});
```

Also update handleDestinationTypeSelect (around line 238):

```tsx
if (type === 'webhook') {
  setDestination({
    integrationId: null,
    integrationType: null,
    tableName: null,
    columnMapping: {},
    contextMapping: {},
    supabaseColumns: [],
    contextColumns: [],
    mappedColumns: [],
    ignoredColumns: [],  // ADD THIS
  });
}
```

In `admin/src/components/ChangeDestinationModal.tsx`, update the state initialization (around line 50):

```tsx
const [config, setConfig] = useState<DestinationConfig>({
  integrationId: currentDestination?.integrationId || null,
  integrationType: currentDestination?.type === "supabase" ? "supabase" : null,
  tableName: currentDestination?.tableName || null,
  columnMapping: currentDestination?.columnMapping || {},
  contextMapping: currentDestination?.contextMapping || {},
  webhookUrl: currentDestination?.webhookUrl || "",
  signingSecret: null,
  supabaseColumns: [],
  contextColumns: [],
  mappedColumns: [],
  ignoredColumns: [],  // ADD THIS
});
```

Also update the useEffect that resets state (around line 70):

```tsx
setConfig({
  integrationId: currentDestination?.integrationId || null,
  integrationType: currentDestination?.type === "supabase" ? "supabase" : null,
  tableName: currentDestination?.tableName || null,
  columnMapping: currentDestination?.columnMapping || {},
  contextMapping: currentDestination?.contextMapping || {},
  webhookUrl: currentDestination?.webhookUrl || "",
  signingSecret: null,
  supabaseColumns: [],
  contextColumns: [],
  mappedColumns: [],
  ignoredColumns: [],  // ADD THIS
});
```

In `admin/src/components/DestinationSelector.tsx`, update handleIntegrationChange (around line 101):

```tsx
onChange({
  integrationId: null,
  integrationType: null,
  tableName: null,
  columnMapping: {},
  contextMapping: {},
  supabaseColumns: [],
  contextColumns: [],
  mappedColumns: [],
  ignoredColumns: [],  // ADD THIS
  webhookUrl: undefined,
  signingSecret: undefined,
});
```

And around line 118:

```tsx
const baseConfig: DestinationConfig = {
  integrationId: integration.id,
  integrationType: integration.type,
  tableName: null,
  columnMapping: {},
  contextMapping: {},
  supabaseColumns: [],
  contextColumns: [],
  mappedColumns: [],
  ignoredColumns: [],  // ADD THIS
  webhookUrl: undefined,
  signingSecret: undefined,
};
```

And in handleTableSelect around line 161:

```tsx
onChange({
  ...value,
  tableName: null,
  supabaseColumns: [],
  contextColumns: [],
  mappedColumns: [],
  ignoredColumns: [],  // ADD THIS
  columnMapping: {},
  contextMapping: {},
});
```

**Step 4: Verify no TypeScript errors**

Run: `cd admin && npm run build 2>&1 | head -50`
Expected: Build succeeds

**Step 5: Commit**

```bash
git add admin/src/components/DestinationSelector.tsx admin/src/app/(dashboard)/importers/new/page.tsx admin/src/components/ChangeDestinationModal.tsx
git commit -m "feat(admin): add ignoredColumns to DestinationConfig"
```

---

## Task 8: Full Integration Test

**Files:** None (verification only)

**Step 1: Run full admin build**

Run: `cd admin && npm run build`
Expected: Build succeeds with no errors

**Step 2: Run admin lint**

Run: `cd admin && npm run lint`
Expected: No lint errors

**Step 3: Start dev server and manually test**

Run: `cd admin && npm run dev`

Manual test steps:
1. Go to /importers/new
2. Define schema via CSV upload or Manual tab
3. Click Next to go to Step 2
4. Select Supabase destination
5. Select a table that doesn't match your schema
6. Verify column mapping UI appears
7. Verify you cannot save without mapping all columns
8. Map or ignore all columns
9. Verify you can now create the importer

**Step 4: Commit any final fixes**

```bash
git add -A
git commit -m "test: verify column mapping integration"
```

---

## Summary

After completing all tasks:

1. **New component:** `ColumnMappingEditor` handles auto-mapping and explicit ignore
2. **DestinationSelector:** Shows mapping UI when schema source ≠ destination table
3. **Validation:** Prevents saving until all columns are mapped or ignored
4. **NOT NULL warnings:** Surfaces required table columns with no source

The mapping UI appears inline after table selection, keeping the flow simple and linear.
