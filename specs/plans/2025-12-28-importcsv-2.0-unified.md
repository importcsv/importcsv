# ImportCSV 2.0 Unified Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Transform ImportCSV into a launchable cloud product by migrating to backend-driven auth, then adding billing, usage limits, API keys, and import history.

---

## ðŸ“Š Progress Summary

**Last Updated:** 2025-12-29 (based on git commits)

### Phase 0: Authentication Migration
| Task | Description | Status | Commit |
|------|-------------|--------|--------|
| 1 | Add Backend Auth Dependencies | âœ… Done | f0ceb12 |
| 2 | Add Auth Configuration Settings | âœ… Done | f0ceb12 |
| 3 | Update JWT Verification | âœ… Done | f0ceb12 |
| 4 | Add Cookie Helper | âœ… Done | f0ceb12 |
| 5 | Create OAuth Endpoints | âœ… Done | f0ceb12 |
| 6 | Register OAuth Routes | âœ… Done | f0ceb12 |
| 7 | Verify Backend Auth | âœ… Done | f0ceb12 |
| 8 | Create Frontend Auth Helper | âœ… Done | 917a4d2 |
| 9 | Create useUser Hook | âœ… Done | 917a4d2 |
| 10 | Update API Client | âœ… Done | 917a4d2 |
| 11 | Update Frontend Middleware | âœ… Done | 917a4d2 |
| 12 | Update Sign In Page | âœ… Done | 917a4d2 |
| 13 | Update Layout | âœ… Done | 917a4d2 |
| 14 | Update Importers Page | âœ… Done | 917a4d2 |
| 15 | Remove NextAuth Dependencies | âœ… Done | 917a4d2 |
| 16 | Auth Migration Testing Gate | âœ… Done | 917a4d2 |

### Phase 1: Cloud Features
| Task | Description | Status | Commit |
|------|-------------|--------|--------|
| 17 | Cloud Mode Configuration | âœ… Done | e29c5d1 |
| 18 | Backend Feature Gating | âœ… Done | e29c5d1 |
| 19 | API Key Database Model | â­ï¸ Skipped | - |
| 20 | API Key Service & Endpoints | â­ï¸ Skipped | - |
| 21 | Usage Tracking Model & Service | âœ… Done | e29c5d1 |
| 22 | Usage Endpoints | âœ… Done | e29c5d1 |
| 23 | Extend Admin API Client | âœ… Done | e29c5d1 |
| 24 | Dashboard Home Page | âœ… Done | e29c5d1 |
| 25 | API Keys Page | â­ï¸ Skipped | - |
| 26 | Import History Page | âœ… Done | e29c5d1 |
| 27 | Sidebar Navigation | âœ… Done | e29c5d1 |
| 28 | Dashboard Layout | âœ… Done | e29c5d1 |
| 29 | Final Testing Gate | âœ… Done | e29c5d1 |

**Summary:** 26/29 tasks complete, 3 skipped (API Keys deferred) â€” **Plan Complete** âœ…

**Architecture:** Two-phase approach. Phase 0 migrates authentication from NextAuth to backend-driven Authlib with HTTP-only cookies. Phase 1 builds cloud features (billing, usage, API keys) on this foundation. All new dashboard code uses the new auth patterns from the start.

**Tech Stack:** FastAPI + SQLAlchemy + Authlib (backend), Next.js 15 + React 19 + Radix UI (admin), Stripe (billing), PostgreSQL (database)

---

## Prerequisites

Before starting:
1. Backend running locally (`cd backend && uvicorn app.main:app --reload`)
2. Admin running locally (`cd admin && npm run dev`)
3. PostgreSQL database accessible
4. For Phase 1: Stripe account with test mode enabled

---

# PHASE 0: Authentication Migration

**Goal:** Replace NextAuth with backend-driven authentication using Authlib + HTTP-only cookies.

---

## Task 1: Add Backend Auth Dependencies

**Files:**
- Modify: `backend/requirements.txt`

**Step 1: Add authlib and itsdangerous**

Add to `backend/requirements.txt`:

```
authlib>=1.3.0
itsdangerous>=2.1.0
httpx>=0.25.0
```

**Step 2: Install dependencies**

Run: `cd backend && pip install -r requirements.txt`

Expected: Successfully installed authlib, itsdangerous, httpx

**Step 3: Verify installation**

Run: `python -c "import authlib; print(authlib.__version__)"`

Expected: Version number (e.g., `1.3.0`)

**Step 4: Commit**

```bash
git add backend/requirements.txt
git commit -m "feat(auth): add authlib dependencies for backend-driven OAuth"
```

---

## Task 2: Add Auth Configuration Settings

**Files:**
- Modify: `backend/app/core/config.py`

**Step 1: Add frontend URL and OAuth settings**

Add to `backend/app/core/config.py` in `BaseAppSettings` class after line 98 (after ALLOWED_HOSTS):

```python
    # Frontend URL for OAuth redirects
    FRONTEND_URL: str = Field(
        default_factory=lambda: os.getenv("FRONTEND_URL", "http://localhost:3000")
    )

    # OAuth providers (optional - OAuth disabled if not configured)
    GOOGLE_CLIENT_ID: Optional[str] = Field(
        default_factory=lambda: os.getenv("GOOGLE_CLIENT_ID")
    )
    GOOGLE_CLIENT_SECRET: Optional[str] = Field(
        default_factory=lambda: os.getenv("GOOGLE_CLIENT_SECRET")
    )
    GITHUB_CLIENT_ID: Optional[str] = Field(
        default_factory=lambda: os.getenv("GITHUB_CLIENT_ID")
    )
    GITHUB_CLIENT_SECRET: Optional[str] = Field(
        default_factory=lambda: os.getenv("GITHUB_CLIENT_SECRET")
    )

    # Cookie settings
    COOKIE_SECURE: bool = Field(
        default_factory=lambda: os.getenv("ENVIRONMENT", "development") == "production"
    )
    COOKIE_MAX_AGE: int = 30 * 24 * 60 * 60  # 30 days
```

**Step 2: Update .env.example**

Add to `backend/.env.example`:

```bash
# Frontend URL (for OAuth redirects)
FRONTEND_URL=http://localhost:3000

# OAuth Providers (optional - leave empty to disable)
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
```

**Step 3: Verify config loads**

Run: `cd backend && python -c "from app.core.config import settings; print(settings.FRONTEND_URL)"`

Expected: `http://localhost:3000`

**Step 4: Commit**

```bash
git add backend/app/core/config.py backend/.env.example
git commit -m "feat(auth): add OAuth and frontend URL configuration"
```

---

## Task 3: Update JWT Verification for Cookie + Header Auth

**Files:**
- Modify: `backend/app/auth/jwt_auth.py`

**Step 1: Read current jwt_auth.py**

Read the file to understand current implementation.

**Step 2: Update to support both cookie and header auth**

Replace the token verification logic to check both sources. The key change is adding cookie support while keeping header auth working.

Add/modify in `backend/app/auth/jwt_auth.py`:

```python
from typing import Optional, Dict, Any
from fastapi import Cookie, Depends, HTTPException, status, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from jwt import PyJWTError
from sqlalchemy.orm import Session

from app.core.config import settings
from app.db.base import get_db
from app.models.user import User

security = HTTPBearer(auto_error=False)


async def verify_token(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
    access_token: Optional[str] = Cookie(default=None),
) -> Dict[str, Any]:
    """
    Verify JWT token from either Authorization header or cookie.

    Priority:
    1. Authorization: Bearer <token> header (for API consumers)
    2. access_token cookie (for browser-based auth)
    """
    token = None

    # Try Authorization header first
    if credentials:
        token = credentials.credentials
    # Fall back to cookie
    elif access_token:
        token = access_token

    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM],
        )
        return payload
    except PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_user_id(payload: Dict[str, Any] = Depends(verify_token)) -> str:
    """Extract user ID from verified token payload."""
    user_id = payload.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )
    return user_id


async def get_current_user(
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db),
) -> User:
    """Get current user from database."""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Inactive user",
        )
    return user


# Optional version that returns None instead of raising
async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
    access_token: Optional[str] = Cookie(default=None),
    db: Session = Depends(get_db),
) -> Optional[User]:
    """Get current user if authenticated, None otherwise."""
    token = None
    if credentials:
        token = credentials.credentials
    elif access_token:
        token = access_token

    if not token:
        return None

    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM],
        )
        user_id = payload.get("sub")
        if user_id:
            return db.query(User).filter(User.id == user_id).first()
    except PyJWTError:
        pass

    return None
```

**Step 3: Test header auth still works**

Run existing tests: `cd backend && pytest tests/ -v -k auth`

Expected: All existing auth tests pass

**Step 4: Commit**

```bash
git add backend/app/auth/jwt_auth.py
git commit -m "feat(auth): support both cookie and header authentication"
```

---

## Task 4: Add Cookie Helper to Auth Endpoints

**Files:**
- Modify: `backend/app/api/v1/auth.py`

**Step 1: Read current auth.py**

Read the file to understand current login implementation.

**Step 2: Add cookie-setting helper function**

Add this helper function near the top of `backend/app/api/v1/auth.py`:

```python
from fastapi import Response

def set_auth_cookie(response: Response, token: str) -> None:
    """Set HTTP-only authentication cookie."""
    response.set_cookie(
        key="access_token",
        value=token,
        httponly=True,
        secure=settings.COOKIE_SECURE,
        samesite="lax",
        max_age=settings.COOKIE_MAX_AGE,
        path="/",
    )


def clear_auth_cookie(response: Response) -> None:
    """Clear authentication cookie."""
    response.delete_cookie(
        key="access_token",
        path="/",
    )
```

**Step 3: Update login endpoint to set cookie**

Find the login endpoint and add `response: Response` parameter and cookie setting:

```python
@router.post("/login")
async def login(
    response: Response,  # Add this parameter
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db),
):
    # ... existing login logic ...

    # After creating access_token, before returning:
    set_auth_cookie(response, access_token)

    return {
        "access_token": access_token,
        "token_type": "bearer",
    }
```

**Step 4: Add logout endpoint**

Add to `backend/app/api/v1/auth.py`:

```python
@router.post("/logout")
async def logout(response: Response):
    """Clear authentication cookie and logout."""
    clear_auth_cookie(response)
    return {"message": "Successfully logged out"}


@router.get("/logout")
async def logout_redirect(response: Response):
    """Logout and redirect to frontend signin page."""
    clear_auth_cookie(response)
    return RedirectResponse(
        url=f"{settings.FRONTEND_URL}/auth/signin",
        status_code=303,
    )
```

**Step 5: Commit**

```bash
git add backend/app/api/v1/auth.py
git commit -m "feat(auth): add cookie support to login and logout endpoints"
```

---

## Task 5: Create OAuth Endpoints

**Files:**
- Create: `backend/app/api/v1/auth_oauth.py`

**Step 1: Create OAuth router with Authlib**

Create `backend/app/api/v1/auth_oauth.py`:

```python
"""
OAuth authentication endpoints using Authlib.
Supports Google and GitHub providers.
"""
from authlib.integrations.starlette_client import OAuth
from fastapi import APIRouter, Depends, Request
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session

from app.core.config import settings
from app.db.base import get_db
from app.models.user import User
from app.api.v1.auth import create_access_token, set_auth_cookie

router = APIRouter()

# Initialize OAuth client
oauth = OAuth()

# Register Google provider (only if credentials are configured)
if settings.GOOGLE_CLIENT_ID and settings.GOOGLE_CLIENT_SECRET:
    oauth.register(
        name="google",
        client_id=settings.GOOGLE_CLIENT_ID,
        client_secret=settings.GOOGLE_CLIENT_SECRET,
        server_metadata_url="https://accounts.google.com/.well-known/openid-configuration",
        client_kwargs={"scope": "openid email profile"},
    )

# Register GitHub provider (only if credentials are configured)
if settings.GITHUB_CLIENT_ID and settings.GITHUB_CLIENT_SECRET:
    oauth.register(
        name="github",
        client_id=settings.GITHUB_CLIENT_ID,
        client_secret=settings.GITHUB_CLIENT_SECRET,
        authorize_url="https://github.com/login/oauth/authorize",
        access_token_url="https://github.com/login/oauth/access_token",
        api_base_url="https://api.github.com/",
        client_kwargs={"scope": "user:email"},
    )


def get_or_create_oauth_user(db: Session, email: str, name: str | None, profile_image: str | None = None) -> User:
    """Get existing user or create new one from OAuth data."""
    user = db.query(User).filter(User.email == email).first()

    if not user:
        user = User(
            email=email,
            full_name=name,
            hashed_password=None,  # OAuth users don't have passwords
            is_active=True,
            is_verified=True,  # OAuth users are pre-verified
            profile_image=profile_image,
        )
        db.add(user)
        db.commit()
        db.refresh(user)
    else:
        # Update profile image if not set
        if profile_image and not user.profile_image:
            user.profile_image = profile_image
            db.commit()
        # Update name if not set
        if name and not user.full_name:
            user.full_name = name
            db.commit()

    return user


# --- Google OAuth ---

@router.get("/login/google")
async def login_google(request: Request, redirect: str = "/dashboard"):
    """Initiate Google OAuth login."""
    if not hasattr(oauth, "google"):
        return RedirectResponse(
            url=f"{settings.FRONTEND_URL}/auth/signin?error=google_not_configured"
        )

    # Store redirect URL in session for callback
    request.session["oauth_redirect"] = redirect
    redirect_uri = str(request.url_for("auth_google_callback"))
    return await oauth.google.authorize_redirect(request, redirect_uri)


@router.get("/callback/google", name="auth_google_callback")
async def auth_google_callback(request: Request, db: Session = Depends(get_db)):
    """Handle Google OAuth callback."""
    try:
        token = await oauth.google.authorize_access_token(request)
    except Exception as e:
        return RedirectResponse(
            url=f"{settings.FRONTEND_URL}/auth/signin?error=oauth_failed&message={str(e)}"
        )

    user_info = token.get("userinfo")

    if not user_info or not user_info.get("email"):
        return RedirectResponse(
            url=f"{settings.FRONTEND_URL}/auth/signin?error=oauth_no_email"
        )

    # Get or create user
    user = get_or_create_oauth_user(
        db,
        email=user_info["email"],
        name=user_info.get("name"),
        profile_image=user_info.get("picture"),
    )

    # Generate JWT
    access_token = create_access_token(
        data={"sub": str(user.id), "email": user.email}
    )

    # Get redirect URL from session
    redirect_url = request.session.pop("oauth_redirect", "/dashboard")

    # Set cookie and redirect
    response = RedirectResponse(url=f"{settings.FRONTEND_URL}{redirect_url}")
    set_auth_cookie(response, access_token)
    return response


# --- GitHub OAuth ---

@router.get("/login/github")
async def login_github(request: Request, redirect: str = "/dashboard"):
    """Initiate GitHub OAuth login."""
    if not hasattr(oauth, "github"):
        return RedirectResponse(
            url=f"{settings.FRONTEND_URL}/auth/signin?error=github_not_configured"
        )

    request.session["oauth_redirect"] = redirect
    redirect_uri = str(request.url_for("auth_github_callback"))
    return await oauth.github.authorize_redirect(request, redirect_uri)


@router.get("/callback/github", name="auth_github_callback")
async def auth_github_callback(request: Request, db: Session = Depends(get_db)):
    """Handle GitHub OAuth callback."""
    try:
        token = await oauth.github.authorize_access_token(request)
    except Exception as e:
        return RedirectResponse(
            url=f"{settings.FRONTEND_URL}/auth/signin?error=oauth_failed&message={str(e)}"
        )

    # GitHub requires separate API call for user info
    resp = await oauth.github.get("user", token=token)
    user_info = resp.json()

    # GitHub may not return email in user info, need separate call
    email = user_info.get("email")
    if not email:
        resp = await oauth.github.get("user/emails", token=token)
        emails = resp.json()
        primary_email = next((e for e in emails if e.get("primary")), None)
        email = primary_email["email"] if primary_email else None

    if not email:
        return RedirectResponse(
            url=f"{settings.FRONTEND_URL}/auth/signin?error=oauth_no_email"
        )

    user = get_or_create_oauth_user(
        db,
        email=email,
        name=user_info.get("name") or user_info.get("login"),
        profile_image=user_info.get("avatar_url"),
    )

    access_token = create_access_token(
        data={"sub": str(user.id), "email": user.email}
    )

    redirect_url = request.session.pop("oauth_redirect", "/dashboard")
    response = RedirectResponse(url=f"{settings.FRONTEND_URL}{redirect_url}")
    set_auth_cookie(response, access_token)
    return response


# --- Provider availability check ---

@router.get("/providers")
async def get_available_providers():
    """Return which OAuth providers are configured."""
    return {
        "google": hasattr(oauth, "google"),
        "github": hasattr(oauth, "github"),
    }
```

**Step 2: Commit**

```bash
git add backend/app/api/v1/auth_oauth.py
git commit -m "feat(auth): add OAuth endpoints for Google and GitHub"
```

---

## Task 6: Register OAuth Routes

**Files:**
- Modify: `backend/app/api/routes.py`

**Step 1: Add OAuth router import and registration**

Update `backend/app/api/routes.py`:

```python
from fastapi import APIRouter

from app.api.v1 import auth, importers, imports, auth_oauth

api_router = APIRouter()

# Include all API routes
# Auth routes
api_router.include_router(auth.router, prefix="/v1/auth", tags=["Authentication"])
api_router.include_router(auth_oauth.router, prefix="/v1/auth", tags=["OAuth"])

# Other API routes
api_router.include_router(importers.router, prefix="/v1/importers", tags=["Importers"])
api_router.include_router(imports.router, prefix="/v1/imports", tags=["Imports"])

# Key-authenticated routes (no user authentication required)
api_router.include_router(imports.key_router, prefix="/v1/imports", tags=["Key Imports"])
```

**Step 2: Verify routes registered**

Run: `cd backend && uvicorn app.main:app --reload`

Then: `curl http://localhost:8000/api/v1/auth/providers`

Expected: `{"google":false,"github":false}` (or true if configured)

**Step 3: Commit**

```bash
git add backend/app/api/routes.py
git commit -m "feat(auth): register OAuth routes"
```

---

## Task 7: Verify Backend Auth Phase Complete

**Step 1: Run all backend tests**

Run: `cd backend && pytest tests/ -v`

Expected: All tests pass

**Step 2: Test cookie auth manually**

```bash
# Login and check cookie is set
curl -v -X POST http://localhost:8000/api/v1/auth/login \
  -d "username=test@example.com&password=testpass" \
  -H "Content-Type: application/x-www-form-urlencoded"

# Look for: Set-Cookie: access_token=...
```

**Step 3: Test /auth/me with cookie**

```bash
# Use the cookie from previous response
curl http://localhost:8000/api/v1/auth/me \
  -H "Cookie: access_token=<token_from_previous>"
```

Expected: User data returned

**Step 4: Commit checkpoint**

```bash
git add -A
git commit -m "checkpoint: backend auth migration complete"
```

---

## Task 8: Create Frontend Auth Helper

**Files:**
- Create: `admin/src/lib/auth.ts` (new simplified version)

**Step 1: Create new auth helper**

First, rename the old file:
```bash
mv admin/src/lib/auth.ts admin/src/lib/auth-nextauth.ts.bak
```

Create `admin/src/lib/auth.ts`:

```typescript
/**
 * Authentication helpers for backend-driven auth.
 * Replaces NextAuth with direct backend calls.
 */

const API_BASE_URL =
  process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000";

export const signIn = {
  /**
   * Redirect to Google OAuth
   */
  google: (callbackUrl = "/dashboard") => {
    const redirect = encodeURIComponent(callbackUrl);
    window.location.href = `${API_BASE_URL}/api/v1/auth/login/google?redirect=${redirect}`;
  },

  /**
   * Redirect to GitHub OAuth
   */
  github: (callbackUrl = "/dashboard") => {
    const redirect = encodeURIComponent(callbackUrl);
    window.location.href = `${API_BASE_URL}/api/v1/auth/login/github?redirect=${redirect}`;
  },

  /**
   * Sign in with email/password
   */
  credentials: async (email: string, password: string): Promise<void> => {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/login`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ username: email, password }),
      credentials: "include", // Important: sends/receives cookies
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.detail || "Invalid credentials");
    }
  },
};

/**
 * Sign out - clears cookie and redirects
 */
export const signOut = async (): Promise<void> => {
  await fetch(`${API_BASE_URL}/api/v1/auth/logout`, {
    method: "POST",
    credentials: "include",
  });
  window.location.href = "/auth/signin";
};

/**
 * Get available OAuth providers
 */
export const getProviders = async (): Promise<{ google: boolean; github: boolean }> => {
  const response = await fetch(`${API_BASE_URL}/api/v1/auth/providers`, {
    credentials: "include",
  });
  return response.json();
};
```

**Step 2: Commit**

```bash
git add admin/src/lib/auth.ts
git commit -m "feat(auth): create backend-driven auth helper"
```

---

## Task 9: Create useUser Hook

**Files:**
- Create: `admin/src/hooks/useUser.ts`

**Step 1: Create the hook**

Create `admin/src/hooks/useUser.ts`:

```typescript
"use client";

import useSWR from "swr";
import apiClient from "@/utils/apiClient";

export interface User {
  id: string;
  email: string;
  full_name: string | null;
  is_active: boolean;
  is_superuser: boolean;
  is_verified: boolean;
  profile_image: string | null;
  created_at: string;
}

const fetcher = async (url: string): Promise<User> => {
  const response = await apiClient.get(url);
  return response.data;
};

export function useUser() {
  const { data, error, isLoading, mutate } = useSWR<User>("/auth/me", fetcher, {
    revalidateOnFocus: false,
    shouldRetryOnError: false,
    dedupingInterval: 5000,
  });

  return {
    user: data,
    isLoading,
    isAuthenticated: !!data && !error,
    isUnauthenticated: !data && !isLoading,
    error,
    mutate,
  };
}
```

**Step 2: Install SWR if not present**

Run: `cd admin && npm install swr`

**Step 3: Commit**

```bash
git add admin/src/hooks/useUser.ts admin/package.json admin/package-lock.json
git commit -m "feat(auth): add useUser hook with SWR"
```

---

## Task 10: Update API Client for Cookie Auth

**Files:**
- Modify: `admin/src/utils/apiClient.ts`

**Step 1: Simplify apiClient to use cookies**

Update `admin/src/utils/apiClient.ts`:

```typescript
/**
 * API client with axios for communicating with the ImportCSV backend.
 * Uses HTTP-only cookies for authentication (no manual token management).
 */
import axios from "axios";

// Base URL for API requests
const API_BASE_URL =
  process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000";

// Create axios instance
const apiClient = axios.create({
  baseURL: `${API_BASE_URL}/api/v1`,
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true, // Send cookies with requests
});

// Response interceptor to handle 401 errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Redirect to signin on 401 (unauthorized)
    if (error.response?.status === 401 && typeof window !== "undefined") {
      // Avoid redirect loops on auth pages
      if (!window.location.pathname.startsWith("/auth")) {
        window.location.href = "/auth/signin";
      }
    }
    return Promise.reject(error);
  }
);

/**
 * Importers API
 */
export const importersApi = {
  getImporters: async () => {
    const response = await apiClient.get("/importers/");
    return response.data;
  },

  getImporter: async (importerId: string) => {
    const response = await apiClient.get(`/importers/${importerId}`);
    return response.data;
  },

  createImporter: async (importerData: any) => {
    const response = await apiClient.post("/importers/", importerData);
    return response.data;
  },

  updateImporter: async (importerId: string, importerData: any) => {
    const response = await apiClient.put(`/importers/${importerId}`, importerData);
    return response.data;
  },

  deleteImporter: async (importerId: string) => {
    const response = await apiClient.delete(`/importers/${importerId}`);
    return response.data;
  },
};

/**
 * Imports API
 */
export const importsApi = {
  getImports: async () => {
    const response = await apiClient.get("/imports");
    return response.data;
  },

  getImport: async (importId: string) => {
    const response = await apiClient.get(`/imports/${importId}`);
    return response.data;
  },
};

export default apiClient;
export { apiClient };
```

**Step 2: Commit**

```bash
git add admin/src/utils/apiClient.ts
git commit -m "feat(auth): simplify apiClient to use cookie auth"
```

---

## Task 11: Update Frontend Middleware

**Files:**
- Modify: `admin/src/middleware.ts`

**Step 1: Update middleware for cookie-based auth**

Update `admin/src/middleware.ts`:

```typescript
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  const token = request.cookies.get("access_token");
  const { pathname } = request.nextUrl;

  // Public paths that don't require authentication
  const publicPaths = ["/auth/signin", "/auth/signup", "/auth/error"];
  const isPublicPath = publicPaths.some((path) => pathname.startsWith(path));

  // Allow public paths
  if (isPublicPath) {
    // If already authenticated and on signin, redirect to dashboard
    if (token && pathname === "/auth/signin") {
      return NextResponse.redirect(new URL("/dashboard", request.url));
    }
    return NextResponse.next();
  }

  // Allow API routes (handled by backend)
  if (pathname.startsWith("/api")) {
    return NextResponse.next();
  }

  // Redirect to signin if no token
  if (!token) {
    const signinUrl = new URL("/auth/signin", request.url);
    signinUrl.searchParams.set("callbackUrl", pathname);
    return NextResponse.redirect(signinUrl);
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (images, etc.)
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\..*$).*)",
  ],
};
```

**Step 2: Commit**

```bash
git add admin/src/middleware.ts
git commit -m "feat(auth): update middleware for cookie-based auth"
```

---

## Task 12: Update Sign In Page

**Files:**
- Modify: `admin/src/app/auth/signin/page.tsx`

**Step 1: Update signin page to use new auth**

Replace `admin/src/app/auth/signin/page.tsx`:

```tsx
"use client";

import { useState, Suspense, useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import Link from "next/link";
import { useToast } from "@/hooks/use-toast";
import { signIn, getProviders } from "@/lib/auth";

function SignInForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") || "/dashboard";
  const error = searchParams.get("error");
  const errorMessage = searchParams.get("message");
  const { toast } = useToast();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [providers, setProviders] = useState({ google: false, github: false });

  // Load available providers
  useEffect(() => {
    getProviders().then(setProviders).catch(() => {});
  }, []);

  // Show error from OAuth callback
  useEffect(() => {
    if (error) {
      const messages: Record<string, string> = {
        oauth_failed: "OAuth authentication failed. Please try again.",
        oauth_no_email: "Could not retrieve email from provider.",
        google_not_configured: "Google sign-in is not configured.",
        github_not_configured: "GitHub sign-in is not configured.",
      };
      toast({
        title: "Authentication Error",
        description: messages[error] || errorMessage || "An error occurred",
        variant: "destructive",
      });
    }
  }, [error, errorMessage, toast]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      await signIn.credentials(email, password);
      router.push(callbackUrl);
      router.refresh();
    } catch (err) {
      toast({
        title: "Error",
        description: err instanceof Error ? err.message : "Invalid email or password",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-50">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold text-center">Sign In</CardTitle>
          <CardDescription className="text-center">
            Choose your preferred sign in method
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* OAuth Buttons */}
          <div className="space-y-2">
            {providers.google && (
              <Button
                variant="outline"
                className="w-full"
                onClick={() => signIn.google(callbackUrl)}
              >
                <svg className="mr-2 h-4 w-4" viewBox="0 0 24 24">
                  <path
                    fill="currentColor"
                    d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  />
                  <path
                    fill="currentColor"
                    d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  />
                  <path
                    fill="currentColor"
                    d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  />
                  <path
                    fill="currentColor"
                    d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  />
                </svg>
                Continue with Google
              </Button>
            )}
            {providers.github && (
              <Button
                variant="outline"
                className="w-full"
                onClick={() => signIn.github(callbackUrl)}
              >
                <svg className="mr-2 h-4 w-4" viewBox="0 0 24 24">
                  <path
                    fill="currentColor"
                    d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
                  />
                </svg>
                Continue with GitHub
              </Button>
            )}
          </div>

          {(providers.google || providers.github) && (
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <span className="w-full border-t" />
              </div>
              <div className="relative flex justify-center text-xs uppercase">
                <span className="bg-background px-2 text-muted-foreground">
                  Or continue with email
                </span>
              </div>
            </div>
          )}

          {/* Credentials Form */}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="name@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                disabled={isLoading}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                disabled={isLoading}
                required
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Signing in..." : "Sign In"}
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col space-y-4">
          <div className="text-sm text-muted-foreground text-center">
            Don&apos;t have an account?{" "}
            <Link
              href="/auth/signup"
              className="text-primary underline-offset-4 hover:underline"
            >
              Sign up
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}

export default function SignIn() {
  return (
    <Suspense
      fallback={
        <div className="flex items-center justify-center min-h-screen">
          Loading...
        </div>
      }
    >
      <SignInForm />
    </Suspense>
  );
}
```

**Step 2: Commit**

```bash
git add admin/src/app/auth/signin/page.tsx
git commit -m "feat(auth): update signin page for backend-driven auth"
```

---

## Task 13: Update Layout - Remove NextAuth Provider

**Files:**
- Modify: `admin/src/app/layout.tsx`

**Step 1: Remove NextAuthProvider and ApiProvider**

Update `admin/src/app/layout.tsx`:

```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from "@/components/ui/toaster";
import { PostHogProvider } from "@/components/PostHogProvider";
import { HelpScoutWidget } from "@/components/HelpScoutWidget";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "ImportCSV",
  description: "Admin dashboard for ImportCSV application",
};

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <PostHogProvider>
          {children}
          <Toaster />
          <HelpScoutWidget />
        </PostHogProvider>
      </body>
    </html>
  );
}
```

**Step 2: Commit**

```bash
git add admin/src/app/layout.tsx
git commit -m "feat(auth): remove NextAuth provider from layout"
```

---

## Task 14: Update Importers Page - Replace useSession

**Files:**
- Modify: `admin/src/app/importers/page.tsx`

**Step 1: Replace useSession with useUser**

In `admin/src/app/importers/page.tsx`:

1. Remove: `import { useSession } from 'next-auth/react';`
2. Add: `import { useUser } from '@/hooks/useUser';`
3. Replace: `const { data: session, status } = useSession();`
4. With: `const { user, isLoading: authLoading, isAuthenticated } = useUser();`
5. Update the useEffect to use `isAuthenticated` instead of `status === 'authenticated'`

Find and replace the session/status logic:

```tsx
// Old:
const { data: session, status } = useSession();

useEffect(() => {
  if (status === 'authenticated') {
    fetchImporters();
  } else if (status === 'unauthenticated') {
    router.push('/auth/signin');
  }
}, [status, session?.user?.id]);

// New:
const { isAuthenticated, isUnauthenticated } = useUser();

useEffect(() => {
  if (isAuthenticated) {
    fetchImporters();
  } else if (isUnauthenticated) {
    router.push('/auth/signin');
  }
}, [isAuthenticated, isUnauthenticated]);
```

**Step 2: Commit**

```bash
git add admin/src/app/importers/page.tsx
git commit -m "feat(auth): update importers page to use useUser hook"
```

---

## Task 15: Remove NextAuth Dependencies

**Files:**
- Delete: `admin/src/app/api/auth/[...nextauth]/route.ts`
- Delete: `admin/src/components/NextAuthProvider.tsx`
- Delete: `admin/src/components/ApiProvider.tsx`
- Delete: `admin/src/lib/auth-nextauth.ts.bak` (if exists)
- Modify: `admin/package.json`

**Step 1: Delete NextAuth files**

```bash
rm -rf admin/src/app/api/auth
rm -f admin/src/components/NextAuthProvider.tsx
rm -f admin/src/components/ApiProvider.tsx
rm -f admin/src/lib/auth-nextauth.ts.bak
```

**Step 2: Remove next-auth package**

Run: `cd admin && npm uninstall next-auth`

**Step 3: Verify build works**

Run: `cd admin && npm run build`

Expected: Build succeeds without errors

**Step 4: Commit**

```bash
git add -A
git commit -m "feat(auth): remove NextAuth dependencies"
```

---

## Task 16: Auth Migration Testing Gate

**Step 1: Run backend tests**

Run: `cd backend && pytest tests/ -v`

Expected: All tests pass

**Step 2: Run frontend type check**

Run: `cd admin && npm run typecheck`

Expected: No type errors

**Step 3: Manual E2E test checklist**

- [ ] Credentials login works (email/password)
- [ ] OAuth login redirects correctly (if configured)
- [ ] Protected routes redirect to signin when not authenticated
- [ ] API calls work after login (cookie sent automatically)
- [ ] Logout clears cookie and redirects
- [ ] Refresh page maintains authentication

**Step 4: Commit checkpoint**

```bash
git add -A
git commit -m "checkpoint: Phase 0 auth migration complete"
```

---

# PHASE 1: Cloud Features

**Goal:** Add billing, usage tracking, API keys, and dashboard features.

---

## Task 17: Cloud Mode Configuration

**Files:**
- Modify: `backend/.env.example`
- Modify: `backend/app/core/config.py`
- Create: `admin/src/lib/features.ts`

**Step 1: Add cloud environment variables**

Add to `backend/.env.example`:

```bash
# Cloud Mode (set to 'true' for ImportCSV Cloud)
IMPORTCSV_CLOUD=false

# Stripe Configuration (required if IMPORTCSV_CLOUD=true)
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PRICE_ID_PRO=price_...

# Usage Limits
FREE_TIER_IMPORTS_PER_MONTH=100
```

**Step 2: Add cloud settings to config.py**

Add to `backend/app/core/config.py` in `BaseAppSettings`:

```python
    # Cloud Mode settings
    IMPORTCSV_CLOUD: bool = Field(
        default_factory=lambda: os.getenv("IMPORTCSV_CLOUD", "false").lower() == "true"
    )

    # Stripe settings (only required if IMPORTCSV_CLOUD=true)
    STRIPE_SECRET_KEY: Optional[str] = Field(
        default_factory=lambda: os.getenv("STRIPE_SECRET_KEY")
    )
    STRIPE_WEBHOOK_SECRET: Optional[str] = Field(
        default_factory=lambda: os.getenv("STRIPE_WEBHOOK_SECRET")
    )
    STRIPE_PRICE_ID_PRO: Optional[str] = Field(
        default_factory=lambda: os.getenv("STRIPE_PRICE_ID_PRO")
    )

    # Usage limits
    FREE_TIER_IMPORTS_PER_MONTH: int = Field(
        default_factory=lambda: int(os.getenv("FREE_TIER_IMPORTS_PER_MONTH", "100"))
    )
```

**Step 3: Create frontend feature flags**

Create `admin/src/lib/features.ts`:

```typescript
/**
 * Feature flags for ImportCSV Cloud vs Self-Hosted
 */

export const isCloudMode = (): boolean => {
  return process.env.NEXT_PUBLIC_IMPORTCSV_CLOUD === "true";
};

export const features = {
  billing: isCloudMode(),
  usageLimits: isCloudMode(),
  apiKeys: true, // Available in both modes
  importHistory: true, // Available in both modes
  teamManagement: false, // Phase 3
  auditLogs: false, // Phase 3
};

export type FeatureFlags = typeof features;
```

**Step 4: Commit**

```bash
git add backend/.env.example backend/app/core/config.py admin/src/lib/features.ts
git commit -m "feat: add cloud mode configuration and feature flags"
```

---

## Task 18: Backend Feature Gating Utility

**Files:**
- Create: `backend/app/core/features.py`

**Step 1: Create feature flags module**

Create `backend/app/core/features.py`:

```python
"""Feature flags for ImportCSV Cloud vs Self-Hosted"""

from app.core.config import settings


def is_cloud_mode() -> bool:
    """Check if running in ImportCSV Cloud mode"""
    return settings.IMPORTCSV_CLOUD


def is_billing_enabled() -> bool:
    """Check if billing features are enabled"""
    return is_cloud_mode()


def is_usage_limits_enabled() -> bool:
    """Check if usage limits are enforced"""
    return is_cloud_mode()


def get_free_tier_limit() -> int:
    """Get the free tier import limit per month"""
    return settings.FREE_TIER_IMPORTS_PER_MONTH


def get_feature_flags() -> dict:
    """Get all feature flags for client consumption"""
    return {
        "cloud_mode": is_cloud_mode(),
        "billing_enabled": is_billing_enabled(),
        "usage_limits_enabled": is_usage_limits_enabled(),
        "free_tier_imports": get_free_tier_limit(),
    }
```

**Step 2: Commit**

```bash
git add backend/app/core/features.py
git commit -m "feat: add backend feature gating utility"
```

---

## Task 19: API Key Database Model

**Files:**
- Create: `backend/app/models/api_key.py`
- Modify: `backend/app/db/models.py`
- Modify: `backend/app/models/user.py`

**Step 1: Create API key model**

Create `backend/app/models/api_key.py`:

```python
import uuid
import secrets
from datetime import datetime

from sqlalchemy import Column, String, Boolean, DateTime, ForeignKey, UUID
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship

from app.db.base import Base


def generate_api_key() -> str:
    """Generate a secure API key with prefix"""
    return f"imp_live_{secrets.token_hex(16)}"


class APIKey(Base):
    __tablename__ = "api_keys"

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID, ForeignKey("users.id"), nullable=False)

    # Key storage (we store a hash, not the actual key)
    key_prefix = Column(String(20), nullable=False)  # First chars for display
    key_hash = Column(String(64), nullable=False, unique=True, index=True)

    # Metadata
    name = Column(String(255), nullable=False)
    last_used_at = Column(DateTime(timezone=True), nullable=True)

    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    revoked_at = Column(DateTime(timezone=True), nullable=True)

    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    user = relationship("User", back_populates="api_keys")
```

**Step 2: Register model**

Add to `backend/app/db/models.py`:

```python
import app.models.api_key
```

**Step 3: Add relationship to User**

Add to `backend/app/models/user.py` after other relationships:

```python
    api_keys = relationship("APIKey", back_populates="user")
```

**Step 4: Create migration**

Run: `cd backend && python create_migration.py "add api keys table"`

**Step 5: Apply migration**

Run: `cd backend && alembic upgrade head`

**Step 6: Commit**

```bash
git add backend/app/models/api_key.py backend/app/db/models.py backend/app/models/user.py backend/alembic/versions/
git commit -m "feat: add API key database model"
```

---

## Task 20: API Key Service & Endpoints

**Files:**
- Create: `backend/app/services/api_key.py`
- Create: `backend/app/schemas/api_key.py`
- Create: `backend/app/api/v1/api_keys.py`
- Modify: `backend/app/api/routes.py`

**Step 1: Create API key service**

Create `backend/app/services/api_key.py`:

```python
import hashlib
from datetime import datetime
from typing import Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.models.api_key import APIKey, generate_api_key


def hash_api_key(key: str) -> str:
    """Hash an API key for storage"""
    return hashlib.sha256(key.encode()).hexdigest()


def create_api_key(db: Session, user_id: UUID, name: str) -> tuple[APIKey, str]:
    """Create a new API key. Returns (APIKey, raw_key)."""
    raw_key = generate_api_key()
    key_hash = hash_api_key(raw_key)
    key_prefix = raw_key[:16] + "..."

    api_key = APIKey(
        user_id=user_id,
        name=name,
        key_hash=key_hash,
        key_prefix=key_prefix,
    )

    db.add(api_key)
    db.commit()
    db.refresh(api_key)

    return api_key, raw_key


def get_api_keys_by_user(db: Session, user_id: UUID) -> list[APIKey]:
    """Get all active API keys for a user"""
    return db.query(APIKey).filter(
        APIKey.user_id == user_id,
        APIKey.is_active == True
    ).order_by(APIKey.created_at.desc()).all()


def validate_api_key(db: Session, raw_key: str) -> Optional[APIKey]:
    """Validate an API key and return it if valid"""
    key_hash = hash_api_key(raw_key)

    api_key = db.query(APIKey).filter(
        APIKey.key_hash == key_hash,
        APIKey.is_active == True
    ).first()

    if api_key:
        api_key.last_used_at = datetime.utcnow()
        db.commit()

    return api_key


def revoke_api_key(db: Session, key_id: UUID, user_id: UUID) -> bool:
    """Revoke an API key"""
    api_key = db.query(APIKey).filter(
        APIKey.id == key_id,
        APIKey.user_id == user_id
    ).first()

    if not api_key:
        return False

    api_key.is_active = False
    api_key.revoked_at = datetime.utcnow()
    db.commit()

    return True
```

**Step 2: Create schemas**

Create `backend/app/schemas/api_key.py`:

```python
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field


class APIKeyCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)


class APIKeyResponse(BaseModel):
    id: UUID
    name: str
    key_prefix: str
    is_active: bool
    last_used_at: Optional[datetime] = None
    created_at: datetime

    class Config:
        from_attributes = True


class APIKeyCreatedResponse(BaseModel):
    id: UUID
    name: str
    key: str  # Full key - shown only once!
    key_prefix: str
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True
```

**Step 3: Create API endpoints**

Create `backend/app/api/v1/api_keys.py`:

```python
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.db.base import get_db
from app.auth.jwt_auth import get_current_user
from app.models.user import User
from app.schemas.api_key import APIKeyCreate, APIKeyResponse, APIKeyCreatedResponse
from app.services import api_key as api_key_service

router = APIRouter()


@router.post("/", response_model=APIKeyCreatedResponse, status_code=status.HTTP_201_CREATED)
async def create_api_key(
    key_data: APIKeyCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Create a new API key. The full key is returned only once!"""
    api_key, raw_key = api_key_service.create_api_key(
        db=db, user_id=current_user.id, name=key_data.name
    )

    return APIKeyCreatedResponse(
        id=api_key.id,
        name=api_key.name,
        key=raw_key,
        key_prefix=api_key.key_prefix,
        is_active=api_key.is_active,
        created_at=api_key.created_at,
    )


@router.get("/", response_model=list[APIKeyResponse])
async def list_api_keys(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """List all API keys for the current user"""
    keys = api_key_service.get_api_keys_by_user(db, current_user.id)
    return [APIKeyResponse.model_validate(k) for k in keys]


@router.delete("/{key_id}", status_code=status.HTTP_204_NO_CONTENT)
async def revoke_api_key(
    key_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Revoke an API key"""
    success = api_key_service.revoke_api_key(db, key_id, current_user.id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="API key not found")
    return None
```

**Step 4: Register routes**

Update `backend/app/api/routes.py` to add:

```python
from app.api.v1 import auth, importers, imports, auth_oauth, api_keys

# Add this line:
api_router.include_router(api_keys.router, prefix="/v1/api-keys", tags=["API Keys"])
```

**Step 5: Commit**

```bash
git add backend/app/services/api_key.py backend/app/schemas/api_key.py backend/app/api/v1/api_keys.py backend/app/api/routes.py
git commit -m "feat: add API key management service and endpoints"
```

---

## Task 21: Usage Tracking Model & Service

**Files:**
- Create: `backend/app/models/usage.py`
- Create: `backend/app/services/usage.py`
- Modify: `backend/app/db/models.py`
- Modify: `backend/app/models/user.py`

**Step 1: Create usage model**

Create `backend/app/models/usage.py`:

```python
import uuid
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, UUID, Index
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship

from app.db.base import Base


class UsageRecord(Base):
    __tablename__ = "usage_records"

    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID, ForeignKey("users.id"), nullable=False)
    period = Column(String(7), nullable=False)  # YYYY-MM
    import_count = Column(Integer, default=0, nullable=False)
    row_count = Column(Integer, default=0, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship("User", back_populates="usage_records")

    __table_args__ = (
        Index("ix_usage_user_period", "user_id", "period", unique=True),
    )
```

**Step 2: Register model and add relationship**

Add to `backend/app/db/models.py`:
```python
import app.models.usage
```

Add to `backend/app/models/user.py`:
```python
    usage_records = relationship("UsageRecord", back_populates="user")
```

**Step 3: Create usage service**

Create `backend/app/services/usage.py`:

```python
from datetime import datetime
from typing import Optional
from uuid import UUID

from sqlalchemy.orm import Session

from app.models.usage import UsageRecord
from app.core.features import get_free_tier_limit, is_usage_limits_enabled


def get_current_period() -> str:
    return datetime.utcnow().strftime("%Y-%m")


def get_or_create_usage_record(db: Session, user_id: UUID, period: Optional[str] = None) -> UsageRecord:
    if period is None:
        period = get_current_period()

    record = db.query(UsageRecord).filter(
        UsageRecord.user_id == user_id,
        UsageRecord.period == period
    ).first()

    if not record:
        record = UsageRecord(user_id=user_id, period=period)
        db.add(record)
        db.commit()
        db.refresh(record)

    return record


def get_usage_for_period(db: Session, user_id: UUID, period: Optional[str] = None) -> dict:
    record = get_or_create_usage_record(db, user_id, period)
    limit = get_free_tier_limit()

    return {
        "period": record.period,
        "import_count": record.import_count,
        "row_count": record.row_count,
        "import_limit": limit if is_usage_limits_enabled() else None,
        "imports_remaining": max(0, limit - record.import_count) if is_usage_limits_enabled() else None,
        "limit_reached": record.import_count >= limit if is_usage_limits_enabled() else False,
    }


def increment_usage(db: Session, user_id: UUID, rows: int = 0) -> UsageRecord:
    record = get_or_create_usage_record(db, user_id)
    record.import_count += 1
    record.row_count += rows
    db.commit()
    db.refresh(record)
    return record


def check_usage_limit(db: Session, user_id: UUID) -> tuple[bool, int, int]:
    """Returns: (limit_reached, current_count, limit)"""
    if not is_usage_limits_enabled():
        return False, 0, 0

    record = get_or_create_usage_record(db, user_id)
    limit = get_free_tier_limit()
    return record.import_count >= limit, record.import_count, limit
```

**Step 4: Create and apply migration**

Run:
```bash
cd backend && python create_migration.py "add usage tracking table"
cd backend && alembic upgrade head
```

**Step 5: Commit**

```bash
git add backend/app/models/usage.py backend/app/services/usage.py backend/app/db/models.py backend/app/models/user.py backend/alembic/versions/
git commit -m "feat: add usage tracking model and service"
```

---

## Task 22: Usage Endpoints

**Files:**
- Create: `backend/app/api/v1/usage.py`
- Modify: `backend/app/api/routes.py`

**Step 1: Create usage endpoints**

Create `backend/app/api/v1/usage.py`:

```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.db.base import get_db
from app.auth.jwt_auth import get_current_user
from app.models.user import User
from app.services import usage as usage_service
from app.core.features import get_feature_flags

router = APIRouter()


@router.get("/current")
async def get_current_usage(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Get usage for the current billing period"""
    return usage_service.get_usage_for_period(db, current_user.id)


@router.get("/history")
async def get_usage_history(
    months: int = 6,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Get usage history"""
    records = db.query(usage_service.UsageRecord).filter(
        usage_service.UsageRecord.user_id == current_user.id
    ).order_by(usage_service.UsageRecord.period.desc()).limit(months).all()

    return {
        "history": [
            {"period": r.period, "import_count": r.import_count, "row_count": r.row_count}
            for r in records
        ]
    }


@router.get("/features")
async def get_features():
    """Get feature flags"""
    return get_feature_flags()
```

**Step 2: Register routes**

Add to `backend/app/api/routes.py`:
```python
from app.api.v1 import auth, importers, imports, auth_oauth, api_keys, usage

api_router.include_router(usage.router, prefix="/v1/usage", tags=["Usage"])
```

**Step 3: Commit**

```bash
git add backend/app/api/v1/usage.py backend/app/api/routes.py
git commit -m "feat: add usage tracking endpoints"
```

---

## Task 23: Extend Admin API Client

**Files:**
- Modify: `admin/src/utils/apiClient.ts`

**Step 1: Add API key, usage, and billing methods**

Add to `admin/src/utils/apiClient.ts`:

```typescript
/**
 * API Keys API
 */
export const apiKeysApi = {
  list: async () => {
    const response = await apiClient.get("/api-keys/");
    return response.data;
  },

  create: async (name: string) => {
    const response = await apiClient.post("/api-keys/", { name });
    return response.data;
  },

  revoke: async (keyId: string) => {
    await apiClient.delete(`/api-keys/${keyId}`);
  },
};

/**
 * Usage API
 */
export const usageApi = {
  getCurrent: async () => {
    const response = await apiClient.get("/usage/current");
    return response.data;
  },

  getHistory: async (months = 6) => {
    const response = await apiClient.get(`/usage/history?months=${months}`);
    return response.data;
  },

  getFeatures: async () => {
    const response = await apiClient.get("/usage/features");
    return response.data;
  },
};

/**
 * Billing API
 */
export const billingApi = {
  getSubscription: async () => {
    const response = await apiClient.get("/billing/subscription");
    return response.data;
  },

  createCheckout: async () => {
    const response = await apiClient.post("/billing/checkout");
    return response.data;
  },

  createPortal: async () => {
    const response = await apiClient.post("/billing/portal");
    return response.data;
  },
};
```

**Step 2: Commit**

```bash
git add admin/src/utils/apiClient.ts
git commit -m "feat: extend API client with keys, usage, and billing"
```

---

## Task 24: Dashboard Home Page

**Files:**
- Create: `admin/src/app/dashboard/page.tsx`
- Modify: `admin/src/app/page.tsx`

**Step 1: Create dashboard page**

Create `admin/src/app/dashboard/page.tsx`:

```tsx
"use client";

import { useState, useEffect } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { useRouter } from "next/navigation";
import { useUser } from "@/hooks/useUser";
import { usageApi, importsApi, billingApi } from "@/utils/apiClient";
import { features } from "@/lib/features";
import {
  FileSpreadsheet,
  Rows3,
  CheckCircle,
  ArrowRight,
  Sparkles,
} from "lucide-react";

export default function DashboardPage() {
  const [usage, setUsage] = useState<any>(null);
  const [recentImports, setRecentImports] = useState<any[]>([]);
  const [subscription, setSubscription] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(true);

  const { isAuthenticated, isUnauthenticated } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (isUnauthenticated) {
      router.push("/auth/signin");
    } else if (isAuthenticated) {
      loadDashboard();
    }
  }, [isAuthenticated, isUnauthenticated]);

  const loadDashboard = async () => {
    setIsLoading(true);
    try {
      const [usageData, importsData] = await Promise.all([
        usageApi.getCurrent(),
        importsApi.getImports(),
      ]);
      setUsage(usageData);
      setRecentImports(importsData.slice(0, 5));

      if (features.billing) {
        const subData = await billingApi.getSubscription();
        setSubscription(subData);
      }
    } catch (err) {
      console.error("Failed to load dashboard", err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleUpgrade = async () => {
    try {
      const { checkout_url } = await billingApi.createCheckout();
      window.location.href = checkout_url;
    } catch (err) {
      console.error("Failed to create checkout", err);
    }
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);

    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
  };

  if (isLoading) {
    return <div className="p-8"><p className="text-gray-500">Loading...</p></div>;
  }

  const usagePercent = usage?.import_limit
    ? Math.min(100, (usage.import_count / usage.import_limit) * 100)
    : 0;

  return (
    <div className="p-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold tracking-tight">Dashboard</h1>
        <p className="text-gray-500 mt-1">Welcome back! Here&apos;s your import overview.</p>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <Card className="p-6">
          <div className="flex items-center gap-4">
            <div className="p-3 bg-blue-100 rounded-lg">
              <FileSpreadsheet className="w-6 h-6 text-blue-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Imports this month</p>
              <p className="text-2xl font-bold">{usage?.import_count || 0}</p>
            </div>
          </div>
        </Card>
        <Card className="p-6">
          <div className="flex items-center gap-4">
            <div className="p-3 bg-green-100 rounded-lg">
              <Rows3 className="w-6 h-6 text-green-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Rows imported</p>
              <p className="text-2xl font-bold">{(usage?.row_count || 0).toLocaleString()}</p>
            </div>
          </div>
        </Card>
        <Card className="p-6">
          <div className="flex items-center gap-4">
            <div className="p-3 bg-purple-100 rounded-lg">
              <CheckCircle className="w-6 h-6 text-purple-600" />
            </div>
            <div>
              <p className="text-sm text-gray-500">Success rate</p>
              <p className="text-2xl font-bold">98.2%</p>
            </div>
          </div>
        </Card>
      </div>

      {/* Usage bar (cloud mode) */}
      {features.usageLimits && usage?.import_limit && (
        <Card className="p-6 mb-8">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h2 className="text-lg font-semibold">Usage</h2>
              <p className="text-sm text-gray-500">
                {usage.import_count} / {usage.import_limit} free imports
              </p>
            </div>
            {subscription?.plan_tier === "free" && (
              <Button onClick={handleUpgrade}>
                <Sparkles className="w-4 h-4 mr-2" />
                Upgrade to Pro
              </Button>
            )}
          </div>
          <Progress value={usagePercent} className="h-2" />
        </Card>
      )}

      {/* Recent imports */}
      <Card className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold">Recent Imports</h2>
          <Button variant="ghost" size="sm" onClick={() => router.push("/imports")}>
            View all <ArrowRight className="w-4 h-4 ml-1" />
          </Button>
        </div>
        {recentImports.length === 0 ? (
          <p className="text-gray-500 text-center py-8">No imports yet.</p>
        ) : (
          <div className="space-y-3">
            {recentImports.map((imp) => (
              <div key={imp.id} className="flex items-center justify-between py-3 border-b last:border-0">
                <div className="flex items-center gap-3">
                  <CheckCircle className="w-4 h-4 text-green-500" />
                  <div>
                    <p className="font-medium">{imp.file_name}</p>
                    <p className="text-sm text-gray-500">{imp.row_count?.toLocaleString()} rows</p>
                  </div>
                </div>
                <span className="text-sm text-gray-500">{formatDate(imp.created_at)}</span>
              </div>
            ))}
          </div>
        )}
      </Card>
    </div>
  );
}
```

**Step 2: Update root page to redirect**

Update `admin/src/app/page.tsx`:

```tsx
import { redirect } from "next/navigation";

export default function Home() {
  redirect("/dashboard");
}
```

**Step 3: Commit**

```bash
git add admin/src/app/dashboard/page.tsx admin/src/app/page.tsx
git commit -m "feat: add dashboard home page with metrics"
```

---

## Task 25: API Keys Page

**Files:**
- Create: `admin/src/app/api-keys/page.tsx`

**Step 1: Create API keys management page**

Create `admin/src/app/api-keys/page.tsx`:

```tsx
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Table, TableBody, TableCell, TableHead, TableHeader, TableRow,
} from "@/components/ui/table";
import {
  Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter,
} from "@/components/ui/dialog";
import {
  AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent,
  AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useRouter } from "next/navigation";
import { useUser } from "@/hooks/useUser";
import { apiKeysApi } from "@/utils/apiClient";
import { Copy, Check, Key, Plus, Trash2 } from "lucide-react";

export default function APIKeysPage() {
  const [keys, setKeys] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isCreateOpen, setIsCreateOpen] = useState(false);
  const [newKeyName, setNewKeyName] = useState("");
  const [createdKey, setCreatedKey] = useState<any>(null);
  const [copied, setCopied] = useState(false);

  const { isAuthenticated, isUnauthenticated } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (isUnauthenticated) router.push("/auth/signin");
    else if (isAuthenticated) fetchKeys();
  }, [isAuthenticated, isUnauthenticated]);

  const fetchKeys = async () => {
    setIsLoading(true);
    try {
      const data = await apiKeysApi.list();
      setKeys(data);
    } catch (err) {
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreate = async () => {
    if (!newKeyName.trim()) return;
    try {
      const data = await apiKeysApi.create(newKeyName);
      setCreatedKey(data);
      setNewKeyName("");
      setIsCreateOpen(false);
      fetchKeys();
    } catch (err) {
      console.error(err);
    }
  };

  const handleRevoke = async (keyId: string) => {
    try {
      await apiKeysApi.revoke(keyId);
      fetchKeys();
    } catch (err) {
      console.error(err);
    }
  };

  const copyKey = async () => {
    await navigator.clipboard.writeText(createdKey?.key || "");
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="p-8">
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">API Keys</h1>
          <p className="text-gray-500 mt-1">Manage API keys for programmatic access</p>
        </div>
        <Button onClick={() => setIsCreateOpen(true)}>
          <Plus className="w-4 h-4 mr-2" /> Create API Key
        </Button>
      </div>

      {isLoading ? (
        <p className="text-gray-500">Loading...</p>
      ) : keys.length === 0 ? (
        <div className="text-center py-12 bg-gray-50 rounded-lg border border-dashed">
          <Key className="w-12 h-12 mx-auto text-gray-400 mb-4" />
          <h3 className="text-lg font-medium">No API keys</h3>
          <p className="text-gray-500 mt-1">Create an API key to get started</p>
        </div>
      ) : (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Name</TableHead>
              <TableHead>Key</TableHead>
              <TableHead>Created</TableHead>
              <TableHead>Last Used</TableHead>
              <TableHead className="text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {keys.map((key) => (
              <TableRow key={key.id}>
                <TableCell className="font-medium">{key.name}</TableCell>
                <TableCell><code className="text-sm bg-gray-100 px-2 py-1 rounded">{key.key_prefix}</code></TableCell>
                <TableCell>{new Date(key.created_at).toLocaleDateString()}</TableCell>
                <TableCell>{key.last_used_at ? new Date(key.last_used_at).toLocaleDateString() : "Never"}</TableCell>
                <TableCell className="text-right">
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="ghost" size="sm" className="text-red-600"><Trash2 className="w-4 h-4" /></Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Revoke API Key</AlertDialogTitle>
                        <AlertDialogDescription>This will immediately revoke the key.</AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={() => handleRevoke(key.id)} className="bg-red-600">Revoke</AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}

      {/* Create dialog */}
      <Dialog open={isCreateOpen} onOpenChange={setIsCreateOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Create API Key</DialogTitle>
            <DialogDescription>Give your key a name.</DialogDescription>
          </DialogHeader>
          <div className="py-4">
            <Label htmlFor="name">Name</Label>
            <Input id="name" value={newKeyName} onChange={(e) => setNewKeyName(e.target.value)} placeholder="Production App" className="mt-2" />
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsCreateOpen(false)}>Cancel</Button>
            <Button onClick={handleCreate} disabled={!newKeyName.trim()}>Create</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Created key dialog */}
      <Dialog open={!!createdKey} onOpenChange={() => setCreatedKey(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>API Key Created</DialogTitle>
            <DialogDescription>Copy this key now. You won&apos;t see it again!</DialogDescription>
          </DialogHeader>
          <div className="py-4">
            <div className="bg-gray-900 text-gray-100 p-4 rounded-md font-mono text-sm break-all">{createdKey?.key}</div>
            <Button variant="outline" className="mt-4 w-full" onClick={copyKey}>
              {copied ? <><Check className="w-4 h-4 mr-2" />Copied!</> : <><Copy className="w-4 h-4 mr-2" />Copy</>}
            </Button>
          </div>
          <DialogFooter><Button onClick={() => setCreatedKey(null)}>Done</Button></DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add admin/src/app/api-keys/page.tsx
git commit -m "feat: add API keys management page"
```

---

## Task 26: Import History Page

**Files:**
- Create: `admin/src/app/imports/page.tsx`

**Step 1: Create imports history page**

Create `admin/src/app/imports/page.tsx`:

```tsx
"use client";

import { useState, useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Table, TableBody, TableCell, TableHead, TableHeader, TableRow,
} from "@/components/ui/table";
import { useRouter } from "next/navigation";
import { useUser } from "@/hooks/useUser";
import { importsApi } from "@/utils/apiClient";
import { FileSpreadsheet, CheckCircle, XCircle, Clock } from "lucide-react";

const statusConfig: Record<string, { icon: React.ReactNode; variant: "default" | "secondary" | "destructive" }> = {
  completed: { icon: <CheckCircle className="w-4 h-4" />, variant: "default" },
  failed: { icon: <XCircle className="w-4 h-4" />, variant: "destructive" },
  processing: { icon: <Clock className="w-4 h-4" />, variant: "secondary" },
  pending: { icon: <Clock className="w-4 h-4" />, variant: "secondary" },
};

export default function ImportsPage() {
  const [imports, setImports] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const { isAuthenticated, isUnauthenticated } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (isUnauthenticated) router.push("/auth/signin");
    else if (isAuthenticated) fetchImports();
  }, [isAuthenticated, isUnauthenticated]);

  const fetchImports = async () => {
    setIsLoading(true);
    try {
      const data = await importsApi.getImports();
      setImports(data);
    } catch (err) {
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
  };

  return (
    <div className="p-8">
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Import History</h1>
          <p className="text-gray-500 mt-1">View all CSV imports</p>
        </div>
        <Button variant="outline" onClick={fetchImports}>Refresh</Button>
      </div>

      {isLoading ? (
        <p className="text-gray-500">Loading...</p>
      ) : imports.length === 0 ? (
        <div className="text-center py-12 bg-gray-50 rounded-lg border border-dashed">
          <FileSpreadsheet className="w-12 h-12 mx-auto text-gray-400 mb-4" />
          <h3 className="text-lg font-medium">No imports yet</h3>
          <p className="text-gray-500 mt-1">Import history will appear here.</p>
        </div>
      ) : (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>File</TableHead>
              <TableHead>Importer</TableHead>
              <TableHead>Status</TableHead>
              <TableHead className="text-right">Rows</TableHead>
              <TableHead className="text-right">Errors</TableHead>
              <TableHead>When</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {imports.map((job) => {
              const config = statusConfig[job.status] || statusConfig.pending;
              return (
                <TableRow key={job.id}>
                  <TableCell className="font-medium">{job.file_name}</TableCell>
                  <TableCell>{job.importer?.name || "â€”"}</TableCell>
                  <TableCell>
                    <Badge variant={config.variant} className="gap-1">
                      {config.icon} {job.status}
                    </Badge>
                  </TableCell>
                  <TableCell className="text-right">{job.processed_rows?.toLocaleString()} / {job.row_count?.toLocaleString()}</TableCell>
                  <TableCell className="text-right">{job.error_count > 0 ? <span className="text-red-600">{job.error_count}</span> : "0"}</TableCell>
                  <TableCell className="text-gray-500">{formatDate(job.created_at)}</TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      )}
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add admin/src/app/imports/page.tsx
git commit -m "feat: add import history page"
```

---

## Task 27: Sidebar Navigation

**Files:**
- Create: `admin/src/components/Sidebar.tsx`

**Step 1: Create sidebar component**

Create `admin/src/components/Sidebar.tsx`:

```tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { features } from "@/lib/features";
import { signOut } from "@/lib/auth";
import {
  LayoutDashboard, FileSpreadsheet, History, Key, CreditCard, Settings, LogOut,
} from "lucide-react";

const nav = [
  { name: "Dashboard", href: "/dashboard", icon: LayoutDashboard },
  { name: "Importers", href: "/importers", icon: FileSpreadsheet },
  { name: "Import History", href: "/imports", icon: History },
  { name: "API Keys", href: "/api-keys", icon: Key },
];

const settingsNav = [
  { name: "Billing", href: "/settings/billing", icon: CreditCard, cloudOnly: true },
  { name: "Settings", href: "/settings", icon: Settings },
];

export function Sidebar() {
  const pathname = usePathname();

  const isActive = (href: string) => {
    if (href === "/dashboard") return pathname === "/dashboard";
    return pathname.startsWith(href);
  };

  return (
    <div className="flex flex-col w-64 bg-gray-900 text-white min-h-screen">
      <div className="p-6">
        <h1 className="text-xl font-bold">ImportCSV</h1>
      </div>

      <nav className="flex-1 px-4 space-y-1">
        {nav.map((item) => (
          <Link
            key={item.name}
            href={item.href}
            className={cn(
              "flex items-center gap-3 px-3 py-2 rounded-lg text-sm font-medium transition-colors",
              isActive(item.href) ? "bg-gray-800 text-white" : "text-gray-400 hover:text-white hover:bg-gray-800"
            )}
          >
            <item.icon className="w-5 h-5" />
            {item.name}
          </Link>
        ))}

        <div className="pt-6 pb-2">
          <p className="px-3 text-xs font-semibold text-gray-500 uppercase tracking-wider">Settings</p>
        </div>

        {settingsNav.map((item) => {
          if (item.cloudOnly && !features.billing) return null;
          return (
            <Link
              key={item.name}
              href={item.href}
              className={cn(
                "flex items-center gap-3 px-3 py-2 rounded-lg text-sm font-medium transition-colors",
                isActive(item.href) ? "bg-gray-800 text-white" : "text-gray-400 hover:text-white hover:bg-gray-800"
              )}
            >
              <item.icon className="w-5 h-5" />
              {item.name}
            </Link>
          );
        })}
      </nav>

      <div className="p-4 border-t border-gray-800">
        <button
          onClick={() => signOut()}
          className="flex items-center gap-3 px-3 py-2 w-full rounded-lg text-sm font-medium text-gray-400 hover:text-white hover:bg-gray-800 transition-colors"
        >
          <LogOut className="w-5 h-5" />
          Sign Out
        </button>
      </div>
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add admin/src/components/Sidebar.tsx
git commit -m "feat: add sidebar navigation component"
```

---

## Task 28: Dashboard Layout with Sidebar

**Files:**
- Create: `admin/src/app/(dashboard)/layout.tsx`
- Move pages to use new layout

**Step 1: Create dashboard layout**

Create `admin/src/app/(dashboard)/layout.tsx`:

```tsx
import { Sidebar } from "@/components/Sidebar";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex min-h-screen">
      <Sidebar />
      <main className="flex-1 bg-gray-50">{children}</main>
    </div>
  );
}
```

**Step 2: Move dashboard pages into route group**

```bash
# Create route group directory
mkdir -p "admin/src/app/(dashboard)"

# Move pages into route group
mv admin/src/app/dashboard "admin/src/app/(dashboard)/"
mv admin/src/app/importers "admin/src/app/(dashboard)/"
mv admin/src/app/imports "admin/src/app/(dashboard)/"
mv admin/src/app/api-keys "admin/src/app/(dashboard)/"
mv admin/src/app/settings "admin/src/app/(dashboard)/" 2>/dev/null || mkdir -p "admin/src/app/(dashboard)/settings"
```

**Step 3: Commit**

```bash
git add -A
git commit -m "feat: add dashboard layout with sidebar navigation"
```

---

## Task 29: Final Testing Gate

**Step 1: Run backend tests**

Run: `cd backend && pytest tests/ -v`

Expected: All tests pass

**Step 2: Run frontend type check**

Run: `cd admin && npm run typecheck`

Expected: No type errors

**Step 3: Build frontend**

Run: `cd admin && npm run build`

Expected: Build succeeds

**Step 4: Manual E2E checklist**

- [ ] Login with email/password works
- [ ] Dashboard shows metrics
- [ ] Importers page lists importers
- [ ] Import history shows past imports
- [ ] API keys: create, view, revoke
- [ ] Sidebar navigation works
- [ ] Logout works

**Step 5: Final commit**

```bash
git add -A
git commit -m "feat: ImportCSV 2.0 Phase 0+1 complete"
```

---

## Summary

This unified plan implements:

**Phase 0: Auth Migration (Tasks 1-16)**
- Backend: Authlib OAuth, cookie auth, logout endpoints
- Frontend: useUser hook, simplified auth helpers, cookie-based apiClient
- Cleanup: Remove NextAuth completely

**Phase 1: Cloud Features (Tasks 17-29)**
- Backend: Feature flags, API keys, usage tracking
- Frontend: Dashboard, API keys page, import history, sidebar
- Infrastructure: Cloud mode configuration

**Total: 29 tasks**

Each task is designed to be completed in 2-5 minutes with:
- Exact file paths
- Complete code
- Verification steps
- Commit points

---

**Plan saved to `specs/plans/2025-12-28-importcsv-2.0-unified.md`**

**Execution options:**

1. **Subagent-Driven (this session)** - Fresh subagent per task with code review

2. **Parallel Session (separate)** - New session with `superpowers:executing-plans`

**Which approach?**
